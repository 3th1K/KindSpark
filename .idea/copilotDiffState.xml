<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessDatabase.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [KindnessPrompt::class, KindnessCompletion::class, SkippedPrompt::class],&#10;    version = 2,&#10;    exportSchema = false&#10;)&#10;abstract class KindnessDatabase : RoomDatabase() {&#10;&#10;    abstract fun kindnessDao(): KindnessPromptDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: KindnessDatabase? = null&#10;&#10;        fun getDatabase(context: Context): KindnessDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    KindnessDatabase::class.java,&#10;                    &quot;kindness_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [KindnessPrompt::class, KindnessCompletion::class, SkippedPrompt::class, UserProgress::class],&#10;    version = 3,&#10;    exportSchema = false&#10;)&#10;abstract class KindnessDatabase : RoomDatabase() {&#10;&#10;    abstract fun kindnessDao(): KindnessPromptDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: KindnessDatabase? = null&#10;&#10;        fun getDatabase(context: Context): KindnessDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    KindnessDatabase::class.java,&#10;                    &quot;kindness_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPrompt.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPrompt.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import java.time.LocalDate&#10;&#10;@Entity(tableName = &quot;kindness_prompts&quot;)&#10;data class KindnessPrompt(&#10;    @PrimaryKey val id: Int,&#10;    val text: String,&#10;    val category: String = &quot;general&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;kindness_completions&quot;)&#10;data class KindnessCompletion(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val promptId: Int,&#10;    val completedDate: String, // Using String to store LocalDate as YYYY-MM-DD&#10;    val isFavorite: Boolean = false,&#10;    val notes: String = &quot;&quot;&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import java.time.LocalDate&#10;&#10;@Entity(tableName = &quot;kindness_prompts&quot;)&#10;data class KindnessPrompt(&#10;    @PrimaryKey val id: Int,&#10;    val text: String,&#10;    val category: String = &quot;general&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;kindness_completions&quot;)&#10;data class KindnessCompletion(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val promptId: Int,&#10;    val completedDate: String, // Using String to store LocalDate as YYYY-MM-DD&#10;    val isFavorite: Boolean = false,&#10;    val notes: String = &quot;&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;skipped_prompts&quot;)&#10;data class SkippedPrompt(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val promptId: Int,&#10;    val skippedDate: String, // Using String to store LocalDate as YYYY-MM-DD&#10;    val reason: String = &quot;&quot; // Optional reason for skipping&#10;)&#10;&#10;data class KindnessPromptWithCompletion(&#10;    val prompt: KindnessPrompt,&#10;    val completion: KindnessCompletion?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPromptDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPromptDao.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface KindnessPromptDao {&#10;&#10;    @Query(&quot;SELECT * FROM kindness_prompts&quot;)&#10;    suspend fun getAllPrompts(): List&lt;KindnessPrompt&gt;&#10;&#10;    @Query(&quot;SELECT * FROM kindness_prompts WHERE id = :id&quot;)&#10;    suspend fun getPromptById(id: Int): KindnessPrompt?&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions ORDER BY completedDate DESC&quot;)&#10;    fun getAllCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE completedDate = :date&quot;)&#10;    suspend fun getCompletionByDate(date: String): KindnessCompletion?&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE isFavorite = 1 ORDER BY completedDate DESC&quot;)&#10;    fun getFavoriteCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.IGNORE)&#10;    suspend fun insertPrompts(prompts: List&lt;KindnessPrompt&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertCompletion(completion: KindnessCompletion): Long&#10;&#10;    @Update&#10;    suspend fun updateCompletion(completion: KindnessCompletion)&#10;&#10;    @Delete&#10;    suspend fun deleteCompletion(completion: KindnessCompletion)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_completions WHERE completedDate BETWEEN :startDate AND :endDate&quot;)&#10;    suspend fun getCompletionCountBetweenDates(startDate: String, endDate: String): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_prompts&quot;)&#10;    suspend fun getPromptCount(): Int&#10;&#10;    // Skipped prompts methods&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertSkippedPrompt(skippedPrompt: SkippedPrompt): Long&#10;&#10;    @Query(&quot;SELECT * FROM skipped_prompts WHERE skippedDate = :date&quot;)&#10;    suspend fun getSkippedPromptsByDate(date: String): List&lt;SkippedPrompt&gt;&#10;&#10;    @Query(&quot;SELECT promptId FROM skipped_prompts WHERE skippedDate = :date&quot;)&#10;    suspend fun getSkippedPromptIdsByDate(date: String): List&lt;Int&gt;&#10;&#10;    @Query(&quot;DELETE FROM skipped_prompts WHERE skippedDate &lt; :cutoffDate&quot;)&#10;    suspend fun deleteOldSkippedPrompts(cutoffDate: String)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface KindnessPromptDao {&#10;&#10;    @Query(&quot;SELECT * FROM kindness_prompts&quot;)&#10;    suspend fun getAllPrompts(): List&lt;KindnessPrompt&gt;&#10;&#10;    @Query(&quot;SELECT * FROM kindness_prompts WHERE id = :id&quot;)&#10;    suspend fun getPromptById(id: Int): KindnessPrompt?&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions ORDER BY completedDate DESC&quot;)&#10;    fun getAllCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE completedDate = :date&quot;)&#10;    suspend fun getCompletionByDate(date: String): KindnessCompletion?&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE isFavorite = 1 ORDER BY completedDate DESC&quot;)&#10;    fun getFavoriteCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.IGNORE)&#10;    suspend fun insertPrompts(prompts: List&lt;KindnessPrompt&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertCompletion(completion: KindnessCompletion): Long&#10;&#10;    @Update&#10;    suspend fun updateCompletion(completion: KindnessCompletion)&#10;&#10;    @Delete&#10;    suspend fun deleteCompletion(completion: KindnessCompletion)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_completions WHERE completedDate BETWEEN :startDate AND :endDate&quot;)&#10;    suspend fun getCompletionCountBetweenDates(startDate: String, endDate: String): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_prompts&quot;)&#10;    suspend fun getPromptCount(): Int&#10;&#10;    // Skipped prompts methods&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertSkippedPrompt(skippedPrompt: SkippedPrompt): Long&#10;&#10;    @Query(&quot;SELECT * FROM skipped_prompts WHERE skippedDate = :date&quot;)&#10;    suspend fun getSkippedPromptsByDate(date: String): List&lt;SkippedPrompt&gt;&#10;&#10;    @Query(&quot;SELECT promptId FROM skipped_prompts WHERE skippedDate = :date&quot;)&#10;    suspend fun getSkippedPromptIdsByDate(date: String): List&lt;Int&gt;&#10;&#10;    @Query(&quot;DELETE FROM skipped_prompts WHERE skippedDate &lt; :cutoffDate&quot;)&#10;    suspend fun deleteOldSkippedPrompts(cutoffDate: String)&#10;&#10;    // UserProgress methods&#10;    @Query(&quot;SELECT * FROM user_progress WHERE id = 1&quot;)&#10;    suspend fun getUserProgress(): UserProgress?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertOrUpdateUserProgress(userProgress: UserProgress)&#10;&#10;    @Query(&quot;UPDATE user_progress SET currentStreak = :streak, lastCompletedDate = :date WHERE id = 1&quot;)&#10;    suspend fun updateStreak(streak: Int, date: String)&#10;&#10;    @Query(&quot;UPDATE user_progress SET bestStreak = :bestStreak WHERE id = 1&quot;)&#10;    suspend fun updateBestStreak(bestStreak: Int)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessRepository.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import kotlinx.coroutines.flow.Flow&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import kotlin.random.Random&#10;&#10;class KindnessRepository(private val dao: KindnessPromptDao) {&#10;&#10;    private val dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)&#10;&#10;    // Pre-defined kindness prompts&#10;    private val defaultPrompts = listOf(&#10;        KindnessPrompt(1, &quot;Compliment someone genuinely.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(2, &quot;Call or text a family member to check on them.&quot;, &quot;family&quot;),&#10;        KindnessPrompt(3, &quot;Help a stranger today in any small way.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(4, &quot;Leave a positive comment on social media.&quot;, &quot;digital&quot;),&#10;        KindnessPrompt(5, &quot;Pick up litter you see on the ground.&quot;, &quot;environment&quot;),&#10;        KindnessPrompt(6, &quot;Support a local business with kind words or a review.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(7, &quot;Hold the door open for someone.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(8, &quot;Write a short thank-you note to someone.&quot;, &quot;gratitude&quot;),&#10;        KindnessPrompt(9, &quot;Donate clothes or items you no longer need.&quot;, &quot;charity&quot;),&#10;        KindnessPrompt(10, &quot;Smile at a stranger and say hello.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(11, &quot;Let someone go ahead of you in line.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(12, &quot;Offer to help a coworker with their tasks.&quot;, &quot;workplace&quot;),&#10;        KindnessPrompt(13, &quot;Send an encouraging message to a friend.&quot;, &quot;friendship&quot;),&#10;        KindnessPrompt(14, &quot;Pay for someone's coffee or meal.&quot;, &quot;generosity&quot;),&#10;        KindnessPrompt(15, &quot;Volunteer for a local charity or cause.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(16, &quot;Listen actively to someone who needs to talk.&quot;, &quot;empathy&quot;),&#10;        KindnessPrompt(17, &quot;Forgive someone who has wronged you.&quot;, &quot;forgiveness&quot;),&#10;        KindnessPrompt(18, &quot;Share your knowledge or skills with others.&quot;, &quot;teaching&quot;),&#10;        KindnessPrompt(19, &quot;Give a genuine compliment to a service worker.&quot;, &quot;appreciation&quot;),&#10;        KindnessPrompt(20, &quot;Plant a flower or tree in your community.&quot;, &quot;environment&quot;)&#10;    )&#10;&#10;    suspend fun initializeDatabase() {&#10;        val promptCount = dao.getPromptCount()&#10;        if (promptCount == 0) {&#10;            dao.insertPrompts(defaultPrompts)&#10;        }&#10;    }&#10;&#10;    suspend fun getDailyPrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;&#10;        // Check if there's already a completion for today&#10;        val existingCompletion = dao.getCompletionByDate(dateString)&#10;&#10;        if (existingCompletion != null) {&#10;            // Return the prompt that was already completed today&#10;            val prompt = dao.getPromptById(existingCompletion.promptId)&#10;            return KindnessPromptWithCompletion(prompt!!, existingCompletion)&#10;        }&#10;&#10;        // Get all prompts and select one randomly&#10;        val allPrompts = dao.getAllPrompts()&#10;        if (allPrompts.isEmpty()) {&#10;            initializeDatabase()&#10;            return getDailyPrompt(date)&#10;        }&#10;&#10;        // Use date as seed for consistent daily prompt&#10;        val seed = date.toEpochDay()&#10;        val randomPrompt = allPrompts[Random(seed).nextInt(allPrompts.size)]&#10;&#10;        return KindnessPromptWithCompletion(randomPrompt, null)&#10;    }&#10;&#10;    suspend fun markPromptAsCompleted(promptId: Int, date: LocalDate = LocalDate.now(), notes: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;        val completion = KindnessCompletion(&#10;            promptId = promptId,&#10;            completedDate = dateString,&#10;            notes = notes&#10;        )&#10;        return dao.insertCompletion(completion)&#10;    }&#10;&#10;    suspend fun toggleFavorite(completion: KindnessCompletion) {&#10;        val updatedCompletion = completion.copy(isFavorite = !completion.isFavorite)&#10;        dao.updateCompletion(updatedCompletion)&#10;    }&#10;&#10;    fun getAllCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;        return dao.getAllCompletions()&#10;    }&#10;&#10;    fun getFavoriteCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;        return dao.getFavoriteCompletions()&#10;    }&#10;&#10;    suspend fun getPromptById(id: Int): KindnessPrompt? {&#10;        return dao.getPromptById(id)&#10;    }&#10;&#10;    suspend fun getCurrentStreak(): Int {&#10;        val today = LocalDate.now()&#10;        var currentDate = today&#10;        var currentDate = today&#10;                currentDate = currentDate.minusDays(1)&#10;            val dateString = currentDate.format(dateFormatter)&#10;                currentDate = currentDate.minusDays(1)&#10;            val dateString = currentDate.format(dateFormatter)&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;        val seed = date.toEpochDay()&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: LocalDate): KindnessPromptWithCompletion {&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;        val cutoffDateString = cutoffDate.format(dateFormatter)&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;        val seed = date.toEpochDay()&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: LocalDate): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay()&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: LocalDate): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay()&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: LocalDate): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay()&#10;        val cutoffDateString = cutoffDate.format(dateFormatter)&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import kotlinx.coroutines.flow.Flow&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import kotlin.random.Random&#10;&#10;class KindnessRepository(private val dao: KindnessPromptDao) {&#10;&#10;    private val dateFormatter = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;&#10;    // Pre-defined kindness prompts&#10;    private val defaultPrompts = listOf(&#10;        KindnessPrompt(1, &quot;Compliment someone genuinely.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(2, &quot;Call or text a family member to check on them.&quot;, &quot;family&quot;),&#10;        KindnessPrompt(3, &quot;Help a stranger today in any small way.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(4, &quot;Leave a positive comment on social media.&quot;, &quot;digital&quot;),&#10;        KindnessPrompt(5, &quot;Pick up litter you see on the ground.&quot;, &quot;environment&quot;),&#10;        KindnessPrompt(6, &quot;Support a local business with kind words or a review.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(7, &quot;Hold the door open for someone.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(8, &quot;Write a short thank-you note to someone.&quot;, &quot;gratitude&quot;),&#10;        KindnessPrompt(9, &quot;Donate clothes or items you no longer need.&quot;, &quot;charity&quot;),&#10;        KindnessPrompt(10, &quot;Smile at a stranger and say hello.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(11, &quot;Let someone go ahead of you in line.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(12, &quot;Offer to help a coworker with their tasks.&quot;, &quot;workplace&quot;),&#10;        KindnessPrompt(13, &quot;Send an encouraging message to a friend.&quot;, &quot;friendship&quot;),&#10;        KindnessPrompt(14, &quot;Pay for someone's coffee or meal.&quot;, &quot;generosity&quot;),&#10;        KindnessPrompt(15, &quot;Volunteer for a local charity or cause.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(16, &quot;Listen actively to someone who needs to talk.&quot;, &quot;empathy&quot;),&#10;        KindnessPrompt(17, &quot;Forgive someone who has wronged you.&quot;, &quot;forgiveness&quot;),&#10;        KindnessPrompt(18, &quot;Share your knowledge or skills with others.&quot;, &quot;teaching&quot;),&#10;        KindnessPrompt(19, &quot;Give a genuine compliment to a service worker.&quot;, &quot;appreciation&quot;),&#10;        KindnessPrompt(20, &quot;Plant a flower or tree in your community.&quot;, &quot;environment&quot;)&#10;    )&#10;&#10;    suspend fun initializeDatabase() {&#10;        val promptCount = dao.getPromptCount()&#10;        if (promptCount == 0) {&#10;            dao.insertPrompts(defaultPrompts)&#10;        }&#10;    }&#10;&#10;    suspend fun getDailyPrompt(date: Date = Date()): KindnessPromptWithCompletion {&#10;        val dateString = dateFormatter.format(date)&#10;&#10;        // Check if there's already a completion for today&#10;        val existingCompletion = dao.getCompletionByDate(dateString)&#10;&#10;        if (existingCompletion != null) {&#10;            // Return the prompt that was already completed today&#10;            val prompt = dao.getPromptById(existingCompletion.promptId)&#10;            return KindnessPromptWithCompletion(prompt!!, existingCompletion)&#10;        }&#10;&#10;        // Get all prompts and select one randomly&#10;        val allPrompts = dao.getAllPrompts()&#10;        if (allPrompts.isEmpty()) {&#10;            initializeDatabase()&#10;            return getDailyPrompt(date)&#10;        }&#10;&#10;        // Use date as seed for consistent daily prompt&#10;        val seed = date.time&#10;        val randomPrompt = allPrompts[Random(seed).nextInt(allPrompts.size)]&#10;&#10;        return KindnessPromptWithCompletion(randomPrompt, null)&#10;    }&#10;&#10;    suspend fun markPromptAsCompleted(promptId: Int, date: Date = Date(), notes: String = &quot;&quot;): Long {&#10;        val dateString = dateFormatter.format(date)&#10;        val completion = KindnessCompletion(&#10;            promptId = promptId,&#10;            completedDate = dateString,&#10;            notes = notes&#10;        )&#10;        return dao.insertCompletion(completion)&#10;    }&#10;&#10;    suspend fun toggleFavorite(completion: KindnessCompletion) {&#10;        val updatedCompletion = completion.copy(isFavorite = !completion.isFavorite)&#10;        dao.updateCompletion(updatedCompletion)&#10;    }&#10;&#10;    fun getAllCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;        return dao.getAllCompletions()&#10;    }&#10;&#10;    fun getFavoriteCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;        return dao.getFavoriteCompletions()&#10;    }&#10;&#10;    suspend fun getPromptById(id: Int): KindnessPrompt? {&#10;        return dao.getPromptById(id)&#10;    }&#10;&#10;    suspend fun getCurrentStreak(): Int {&#10;        val today = Date()&#10;        val calendar = Calendar.getInstance()&#10;        var streak = 0&#10;        &#10;        calendar.time = today&#10;&#10;        // Check backwards from today to find consecutive days&#10;        while (true) {&#10;            val dateString = dateFormatter.format(calendar.time)&#10;            val completion = dao.getCompletionByDate(dateString)&#10;&#10;            if (completion != null) {&#10;                streak++&#10;                calendar.add(Calendar.DAY_OF_MONTH, -1) // Go back one day&#10;            } else {&#10;                break&#10;            }&#10;        }&#10;&#10;        return streak&#10;    }&#10;&#10;    suspend fun skipPrompt(promptId: Int, date: Date = Date(), reason: String = &quot;&quot;): Long {&#10;        val dateString = dateFormatter.format(date)&#10;        val skippedPrompt = SkippedPrompt(&#10;            promptId = promptId,&#10;            skippedDate = dateString,&#10;            reason = reason&#10;        )&#10;        return dao.insertSkippedPrompt(skippedPrompt)&#10;    }&#10;&#10;    suspend fun getNextAvailablePrompt(date: Date = Date()): KindnessPromptWithCompletion {&#10;        val dateString = dateFormatter.format(date)&#10;&#10;        // Get all prompts&#10;        val allPrompts = dao.getAllPrompts()&#10;        if (allPrompts.isEmpty()) {&#10;            initializeDatabase()&#10;            return getNextAvailablePrompt(date)&#10;        }&#10;&#10;        // Get prompts that have been skipped today&#10;        val skippedTodayIds = dao.getSkippedPromptIdsByDate(dateString)&#10;&#10;        // Filter out skipped prompts&#10;        val availablePrompts = allPrompts.filter { it.id !in skippedTodayIds }&#10;&#10;        if (availablePrompts.isEmpty()) {&#10;            // If all prompts have been skipped, clear today's skips and start over&#10;            // This prevents users from being stuck with no prompts&#10;            return getRandomPromptFromAll(allPrompts, date)&#10;        }&#10;&#10;        // Use date as seed for consistent selection, but add skip count to vary selection&#10;        val seed = date.time + skippedTodayIds.size&#10;        val selectedPrompt = availablePrompts[Random(seed).nextInt(availablePrompts.size)]&#10;&#10;        return KindnessPromptWithCompletion(selectedPrompt, null)&#10;    }&#10;&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: Date): KindnessPromptWithCompletion {&#10;        val seed = date.time&#10;        val randomPrompt = allPrompts[Random(seed).nextInt(allPrompts.size)]&#10;        return KindnessPromptWithCompletion(randomPrompt, null)&#10;    }&#10;&#10;    suspend fun cleanupOldSkippedPrompts(daysToKeep: Int = 7) {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.add(Calendar.DAY_OF_MONTH, -daysToKeep)&#10;        val cutoffDateString = dateFormatter.format(calendar.time)&#10;        dao.deleteOldSkippedPrompts(cutoffDateString)&#10;    }&#10;&#10;    // UserProgress and Streak Management&#10;    suspend fun getUserProgress(): UserProgress {&#10;        return dao.getUserProgress() ?: UserProgress(&#10;            id = 1,&#10;            currentStreak = 0,&#10;            bestStreak = 0,&#10;            lastCompletedDate = &quot;&quot;,&#10;            totalCompleted = 0,&#10;            startDate = dateFormatter.format(Date())&#10;        ).also {&#10;            dao.insertOrUpdateUserProgress(it)&#10;        }&#10;    }&#10;&#10;    suspend fun updateStreakOnCompletion(completionDate: Date = Date()): UserProgress {&#10;        val currentProgress = getUserProgress()&#10;        val completionDateString = dateFormatter.format(completionDate)&#10;&#10;        // Don't update streak if already completed today&#10;        if (currentProgress.lastCompletedDate == completionDateString) {&#10;            return currentProgress&#10;        }&#10;&#10;        val newStreak = when {&#10;            currentProgress.lastCompletedDate.isEmpty() -&gt; 1 // First completion&#10;            isConsecutiveDay(currentProgress.lastCompletedDate, completionDateString) -&gt; currentProgress.currentStreak + 1&#10;            else -&gt; 1 // Streak broken, start over&#10;        }&#10;&#10;        val newBestStreak = maxOf(newStreak, currentProgress.bestStreak)&#10;        val newTotalCompleted = currentProgress.totalCompleted + 1&#10;&#10;        val updatedProgress = currentProgress.copy(&#10;            currentStreak = newStreak,&#10;            bestStreak = newBestStreak,&#10;            lastCompletedDate = completionDateString,&#10;            totalCompleted = newTotalCompleted&#10;        )&#10;&#10;        dao.insertOrUpdateUserProgress(updatedProgress)&#10;        return updatedProgress&#10;    }&#10;&#10;    private fun isConsecutiveDay(lastCompletedDate: String, newCompletionDate: String): Boolean {&#10;        if (lastCompletedDate.isEmpty()) return false&#10;&#10;        try {&#10;            val lastDate = dateFormatter.parse(lastCompletedDate) ?: return false&#10;            val newDate = dateFormatter.parse(newCompletionDate) ?: return false&#10;            &#10;            val calendar = Calendar.getInstance()&#10;            calendar.time = lastDate&#10;            calendar.add(Calendar.DAY_OF_MONTH, 1) // Add one day to last date&#10;            &#10;            // Check if the new completion is exactly one day after the last completion&#10;            val expectedDate = dateFormatter.format(calendar.time)&#10;            return expectedDate == newCompletionDate&#10;        } catch (e: Exception) {&#10;            return false&#10;        }&#10;    }&#10;&#10;    suspend fun getStreakMilestones(currentStreak: Int): List&lt;Int&gt; {&#10;        // Return milestone numbers that were just reached&#10;        val milestones = listOf(3, 7, 14, 21, 30, 50, 100)&#10;        return milestones.filter { milestone -&gt;&#10;            currentStreak == milestone&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/UserProgress.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/UserProgress.kt" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;user_progress&quot;)&#10;data class UserProgress(&#10;    @PrimaryKey val id: Int = 1, // Single row for user progress&#10;    val currentStreak: Int = 0,&#10;    val bestStreak: Int = 0,&#10;    val lastCompletedDate: String = &quot;&quot;, // YYYY-MM-DD format&#10;    val totalCompleted: Int = 0,&#10;    val startDate: String = &quot;&quot; // When user first started using the app&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/notifications/NotificationScheduler.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/notifications/NotificationScheduler.kt" />
              <option name="updatedContent" value="package com.example.kindspark.notifications&#10;&#10;import android.content.Context&#10;import androidx.work.*&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import kotlinx.coroutines.flow.first&#10;import java.util.concurrent.TimeUnit&#10;&#10;class NotificationScheduler(&#10;    private val context: Context,&#10;    private val preferencesManager: UserPreferencesManager&#10;) {&#10;&#10;    companion object {&#10;        private const val KINDNESS_REMINDER_WORK = &quot;kindness_reminder_work&quot;&#10;    }&#10;&#10;    suspend fun scheduleNotifications() {&#10;        val isEnabled = preferencesManager.notificationEnabled.first()&#10;        val interval = preferencesManager.notificationInterval.first()&#10;&#10;        // Cancel existing work&#10;        WorkManager.getInstance(context).cancelUniqueWork(KINDNESS_REMINDER_WORK)&#10;&#10;        // Only schedule if notifications are enabled&#10;        if (!isEnabled) return&#10;&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.NOT_REQUIRED)&#10;            .setRequiresBatteryNotLow(false)&#10;            .setRequiresCharging(false)&#10;            .build()&#10;&#10;        val workRequest = PeriodicWorkRequestBuilder&lt;NotificationWorker&gt;(&#10;            interval.hours.toLong(),&#10;            TimeUnit.HOURS,&#10;            // Add flex time for better battery optimization&#10;            15,&#10;            TimeUnit.MINUTES&#10;        )&#10;            .setConstraints(constraints)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.LINEAR,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .build()&#10;&#10;        WorkManager.getInstance(context).enqueueUniquePeriodicWork(&#10;            KINDNESS_REMINDER_WORK,&#10;            ExistingPeriodicWorkPolicy.REPLACE,&#10;            workRequest&#10;        )&#10;    }&#10;&#10;    fun cancelNotifications() {&#10;        WorkManager.getInstance(context).cancelUniqueWork(KINDNESS_REMINDER_WORK)&#10;    }&#10;&#10;    suspend fun rescheduleNotifications() {&#10;        scheduleNotifications()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/notifications/NotificationWorker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/notifications/NotificationWorker.kt" />
              <option name="updatedContent" value="package com.example.kindspark.notifications&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import androidx.work.CoroutineWorker&#10;import androidx.work.WorkerParameters&#10;import com.example.kindspark.MainActivity&#10;import com.example.kindspark.R&#10;import com.example.kindspark.data.KindnessDatabase&#10;import com.example.kindspark.data.KindnessRepository&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlin.random.Random&#10;&#10;class NotificationWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;kindness_reminders&quot;&#10;        const val NOTIFICATION_ID = 1&#10;    }&#10;&#10;    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Get a random kindness prompt&#10;            val database = KindnessDatabase.getDatabase(applicationContext)&#10;            val repository = KindnessRepository(database.kindnessDao())&#10;&#10;            // Initialize database if needed&#10;            repository.initializeDatabase()&#10;&#10;            // Get a random prompt for the notification&#10;            val prompts = database.kindnessDao().getAllPrompts()&#10;            if (prompts.isEmpty()) {&#10;                return@withContext Result.failure()&#10;            }&#10;&#10;            val randomPrompt = prompts[Random.nextInt(prompts.size)]&#10;&#10;            // Create and show notification&#10;            createNotificationChannel()&#10;            showNotification(randomPrompt.text)&#10;&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.failure()&#10;        }&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Kindness Reminders&quot;,&#10;                NotificationManager.IMPORTANCE_DEFAULT&#10;            ).apply {&#10;                description = &quot;Daily reminders for acts of kindness&quot;&#10;                enableVibration(true)&#10;            }&#10;&#10;            val notificationManager = applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun showNotification(promptText: String) {&#10;        val intent = Intent(applicationContext, MainActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            applicationContext,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val notification = NotificationCompat.Builder(applicationContext, CHANNEL_ID)&#10;            .setContentTitle(&quot;Time for Kindness ✨&quot;)&#10;            .setContentText(promptText)&#10;            .setStyle(NotificationCompat.BigTextStyle().bigText(promptText))&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info) // Using system icon instead of custom&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;            .build()&#10;&#10;        val notificationManager = applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.notify(NOTIFICATION_ID, notification)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/animations/LottieCelebration.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/animations/LottieCelebration.kt" />
              <option name="updatedContent" value="package com.example.kindspark.ui.animations&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun LottieCelebration(&#10;    isVisible: Boolean,&#10;    onAnimationComplete: () -&gt; Unit,&#10;    title: String = &quot;Great Job! &quot;,&#10;    subtitle: String = &quot;You completed an act of kindness!&quot;,&#10;    streakInfo: String? = null,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    if (isVisible) {&#10;        Dialog(&#10;            onDismissRequest = onAnimationComplete,&#10;            properties = DialogProperties(&#10;                dismissOnBackPress = true,&#10;                dismissOnClickOutside = true,&#10;                usePlatformDefaultWidth = false&#10;            )&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(Color.Black.copy(alpha = 0.7f)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                AnimatedVisibility(&#10;                    visible = isVisible,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut()&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .padding(32.dp)&#10;                            .fillMaxWidth(),&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                        )&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(32.dp)&#10;                                .fillMaxWidth(),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            // Animated emoji as placeholder for Lottie&#10;                            // TODO: Replace with actual Lottie animation when library is added&#10;                            AnimatedEmoji()&#10;                            &#10;                            Spacer(modifier = Modifier.height(24.dp))&#10;                            &#10;                            Text(&#10;                                text = title,&#10;                                style = MaterialTheme.typography.headlineMedium,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                                textAlign = TextAlign.Center&#10;                            )&#10;                            &#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            &#10;                            Text(&#10;                                text = subtitle,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                                textAlign = TextAlign.Center&#10;                            )&#10;                            &#10;                            streakInfo?.let { info -&gt;&#10;                                Spacer(modifier = Modifier.height(16.dp))&#10;                                Card(&#10;                                    colors = CardDefaults.cardColors(&#10;                                        containerColor = MaterialTheme.colorScheme.primary&#10;                                    )&#10;                                ) {&#10;                                    Text(&#10;                                        text = info,&#10;                                        style = MaterialTheme.typography.titleMedium,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = MaterialTheme.colorScheme.onPrimary,&#10;                                        modifier = Modifier.padding(16.dp),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            &#10;                            Spacer(modifier = Modifier.height(24.dp))&#10;                            &#10;                            Button(&#10;                                onClick = onAnimationComplete,&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            ) {&#10;                                Text(&quot;Continue&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        LaunchedEffect(isVisible) {&#10;            if (isVisible) {&#10;                // Auto-dismiss after 3 seconds if user doesn't interact&#10;                delay(3000)&#10;                onAnimationComplete()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AnimatedEmoji() {&#10;    // Placeholder animated emoji - can be replaced with Lottie when added&#10;    var scale by remember { mutableFloatStateOf(1f) }&#10;    &#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            scale = 1.2f&#10;            delay(500)&#10;            scale = 1f&#10;            delay(500)&#10;        }&#10;    }&#10;    &#10;    Text(&#10;        text = &quot;✨&quot;,&#10;        style = MaterialTheme.typography.displayLarge,&#10;        modifier = Modifier&#10;            .padding(16.dp)&#10;    )&#10;}&#10;&#10;// Milestone-specific celebrations&#10;@Composable&#10;fun MilestoneCelebration(&#10;    isVisible: Boolean,&#10;    milestone: Int,&#10;    onAnimationComplete: () -&gt; Unit&#10;) {&#10;    val (title, subtitle, emoji) = when (milestone) {&#10;        3 -&gt; Triple(&quot;Amazing Start! &quot;, &quot;3-day streak achieved!&quot;, &quot;&quot;)&#10;        7 -&gt; Triple(&quot;One Week Strong! &quot;, &quot;7-day kindness streak!&quot;, &quot;⭐&quot;)&#10;        14 -&gt; Triple(&quot;Two Weeks of Kindness! &quot;, &quot;You're on fire!&quot;, &quot;&quot;)&#10;        21 -&gt; Triple(&quot;Habit Formed! &quot;, &quot;21 days of kindness!&quot;, &quot;&quot;)&#10;        30 -&gt; Triple(&quot;Monthly Champion! &quot;, &quot;30 days of spreading joy!&quot;, &quot;✨&quot;)&#10;        50 -&gt; Triple(&quot;Kindness Hero! &quot;, &quot;50 days of making a difference!&quot;, &quot;⚡&quot;)&#10;        100 -&gt; Triple(&quot;Legendary! &quot;, &quot;100 days of pure kindness!&quot;, &quot;&quot;)&#10;        else -&gt; Triple(&quot;Streak Milestone! &quot;, &quot;$milestone days of kindness!&quot;, &quot;✨&quot;)&#10;    }&#10;&#10;    LottieCelebration(&#10;        isVisible = isVisible,&#10;        onAnimationComplete = onAnimationComplete,&#10;        title = title,&#10;        subtitle = subtitle,&#10;        streakInfo = &quot; $milestone Day Streak!&quot;&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.KindnessCompletion&#10;import com.example.kindspark.data.KindnessPromptWithCompletion&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.data.UserProgress&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;        }&#10;    }&#10;&#10;    fun markAsCompleted(notes: String = &quot;&quot;) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentPrompt = _uiState.value.dailyPrompt?.prompt&#10;                if (currentPrompt != null) {&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val updatedProgress = repository.updateStreakOnCompletion()&#10;                    val updatedProgress = repository.updateStreakOnCompletion()&#10;                    val updatedProgress = repository.updateStreakOnCompletion()&#10;                        completedDate = LocalDate.now().toString(),&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.KindnessCompletion&#10;import com.example.kindspark.data.KindnessPromptWithCompletion&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.data.UserProgress&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;data class HomeUiState(&#10;    val dailyPrompt: KindnessPromptWithCompletion? = null,&#10;    val currentStreak: Int = 0,&#10;    val bestStreak: Int = 0,&#10;    val totalCompleted: Int = 0,&#10;    val isCompleted: Boolean = false,&#10;    val isLoading: Boolean = true,&#10;    val error: String? = null,&#10;    val showCelebration: Boolean = false,&#10;    val celebrationMilestone: Int? = null,&#10;    val userProgress: UserProgress? = null&#10;)&#10;&#10;class HomeViewModel(&#10;    private val repository: KindnessRepository,&#10;    private val preferencesManager: UserPreferencesManager,&#10;    private val notificationScheduler: NotificationScheduler&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadDailyPrompt()&#10;        loadCurrentStreak()&#10;    }&#10;&#10;    private fun loadDailyPrompt() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;                val promptWithCompletion = repository.getDailyPrompt()&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    dailyPrompt = promptWithCompletion,&#10;                    isCompleted = promptWithCompletion.completion != null,&#10;                    isLoading = false,&#10;                    error = null&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Failed to load daily prompt: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadCurrentStreak() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val userProgress = repository.getUserProgress()&#10;                _uiState.value = _uiState.value.copy(&#10;                    currentStreak = userProgress.currentStreak,&#10;                    bestStreak = userProgress.bestStreak,&#10;                    totalCompleted = userProgress.totalCompleted,&#10;                    userProgress = userProgress&#10;                )&#10;            } catch (e: Exception) {&#10;                // Handle error silently for streak, it's not critical&#10;            }&#10;        }&#10;    }&#10;&#10;    fun markAsCompleted(notes: String = &quot;&quot;) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentPrompt = _uiState.value.dailyPrompt?.prompt&#10;                if (currentPrompt != null) {&#10;                    val today = Date()&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, today, notes)&#10;&#10;                    // Update streak and get updated progress&#10;                    val updatedProgress = repository.updateStreakOnCompletion(today)&#10;&#10;                    // Check for milestone celebration&#10;                    val milestones = repository.getStreakMilestones(updatedProgress.currentStreak)&#10;                    val shouldCelebrate = milestones.isNotEmpty()&#10;&#10;                    // Update UI state&#10;                    val dateFormatter = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;                    val completion = KindnessCompletion(&#10;                        id = completionId,&#10;                        promptId = currentPrompt.id,&#10;                        completedDate = dateFormatter.format(today),&#10;                        notes = notes&#10;                    )&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        dailyPrompt = _uiState.value.dailyPrompt?.copy(completion = completion),&#10;                        isCompleted = true,&#10;                        currentStreak = updatedProgress.currentStreak,&#10;                        bestStreak = updatedProgress.bestStreak,&#10;                        totalCompleted = updatedProgress.totalCompleted,&#10;                        userProgress = updatedProgress,&#10;                        showCelebration = shouldCelebrate,&#10;                        celebrationMilestone = milestones.firstOrNull()&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    error = &quot;Failed to mark as completed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleFavorite() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val completion = _uiState.value.dailyPrompt?.completion&#10;                if (completion != null) {&#10;                    repository.toggleFavorite(completion)&#10;&#10;                    // Update UI state&#10;                    _uiState.value = _uiState.value.copy(&#10;                        dailyPrompt = _uiState.value.dailyPrompt?.copy(&#10;                            completion = completion.copy(isFavorite = !completion.isFavorite)&#10;                        )&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    error = &quot;Failed to toggle favorite: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    fun refreshPrompt() {&#10;        loadDailyPrompt()&#10;        loadCurrentStreak()&#10;    }&#10;&#10;    fun skipCurrentPrompt() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentPrompt = _uiState.value.dailyPrompt?.prompt&#10;                if (currentPrompt != null) {&#10;                    // Skip the current prompt&#10;                    repository.skipPrompt(currentPrompt.id, Date())&#10;&#10;                    // Get the next available prompt&#10;                    val nextPrompt = repository.getNextAvailablePrompt()&#10;&#10;                    // Update UI state with the new prompt&#10;                    _uiState.value = _uiState.value.copy(&#10;                        dailyPrompt = nextPrompt,&#10;                        isCompleted = false // New prompt is not completed&#10;                    )&#10;&#10;                    // Clean up old skipped prompts (keep only last 7 days)&#10;                    repository.cleanupOldSkippedPrompts()&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    error = &quot;Failed to skip prompt: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun dismissCelebration() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showCelebration = false,&#10;            celebrationMilestone = null&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModelFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModelFactory.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.PreferencesManager&#10;import com.example.kindspark.notifications.DailyNotificationScheduler&#10;&#10;class HomeViewModelFactory(&#10;    private val repository: KindnessRepository,&#10;    private val preferencesManager: PreferencesManager,&#10;    private val notificationScheduler: DailyNotificationScheduler&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(HomeViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return HomeViewModel(repository, preferencesManager, notificationScheduler) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;&#10;class HomeViewModelFactory(&#10;    private val repository: KindnessRepository,&#10;    private val userPreferencesManager: UserPreferencesManager,&#10;    private val notificationScheduler: NotificationScheduler&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(HomeViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return HomeViewModel(repository, userPreferencesManager, notificationScheduler) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/log/LogScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/log/LogScreen.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.log&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.FavoriteBorder&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.kindspark.utils.DateUtils&#10;import java.time.LocalDate&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogScreen(&#10;    viewModel: LogViewModel,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    var selectedTab by remember { mutableIntStateOf(0) }&#10;&#10;    Column(modifier = modifier.fillMaxSize()) {&#10;        // Header&#10;        Text(&#10;            text = &quot;Kindness Log&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        )&#10;&#10;        // Tab Row&#10;        TabRow(&#10;            selectedTabIndex = selectedTab,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Tab(&#10;                selected = selectedTab == 0,&#10;                onClick = { selectedTab = 0 },&#10;                text = { Text(&quot;All Completions&quot;) }&#10;            )&#10;            Tab(&#10;                selected = selectedTab == 1,&#10;                onClick = { selectedTab = 1 },&#10;                text = { Text(&quot;Favorites&quot;) }&#10;            )&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            uiState.isLoading -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            }&#10;&#10;            uiState.error != null -&gt; {&#10;                ErrorMessage(&#10;                    error = uiState.error,&#10;                    onDismiss = { viewModel.clearError() }&#10;                )&#10;            }&#10;&#10;            else -&gt; {&#10;                val itemsToShow = if (selectedTab == 0) uiState.completions else uiState.favorites&#10;&#10;                if (itemsToShow.isEmpty()) {&#10;                    EmptyState(&#10;                        message = if (selectedTab == 0)&#10;                            &quot;No completed acts of kindness yet. Start your journey today!&quot;&#10;                        else&#10;                            &quot;No favorites yet. Mark your favorite acts of kindness!&quot;&#10;                    )&#10;                } else {&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentPadding = PaddingValues(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(itemsToShow) { completionWithPrompt -&gt;&#10;                            CompletionCard(&#10;                                completionWithPrompt = completionWithPrompt,&#10;                                onToggleFavorite = { viewModel.toggleFavorite(completionWithPrompt.completion) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CompletionCard(&#10;    completionWithPrompt: CompletionWithPrompt,&#10;    onToggleFavorite: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            // Header with date and favorite button&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                val date = DateUtils.parseDateFromDatabase(completionWithPrompt.completion.completedDate)&#10;                Text(&#10;                    text = DateUtils.getRelativeDateString(date),&#10;                    style = MaterialTheme.typography.labelMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                IconButton(onClick = onToggleFavorite) {&#10;                    Icon(&#10;                        if (completionWithPrompt.completion.isFavorite)&#10;                            Icons.Default.Favorite&#10;                        else&#10;                            Icons.Default.FavoriteBorder,&#10;                        contentDescription = &quot;Toggle Favorite&quot;,&#10;                        tint = if (completionWithPrompt.completion.isFavorite)&#10;                            MaterialTheme.colorScheme.error&#10;                        else&#10;                            MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Prompt text&#10;            Text(&#10;                text = completionWithPrompt.prompt.text,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Notes if available&#10;            if (completionWithPrompt.completion.notes.isNotEmpty()) {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot; ${completionWithPrompt.completion.notes}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;&#10;            // Category badge&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Surface(&#10;                shape = RoundedCornerShape(16.dp),&#10;                color = MaterialTheme.colorScheme.secondaryContainer&#10;            ) {&#10;                Text(&#10;                    text = completionWithPrompt.prompt.category,&#10;                    style = MaterialTheme.typography.labelSmall,&#10;                    color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptyState(&#10;    message: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;✨&quot;,&#10;                style = MaterialTheme.typography.headlineLarge&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = message,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                textAlign = TextAlign.Center,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorMessage(&#10;    error: String,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Error&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onErrorContainer,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Text(&#10;                text = error,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onErrorContainer&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Dismiss&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.log&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.FavoriteBorder&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.kindspark.utils.DateUtils&#10;import java.time.LocalDate&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogScreen(&#10;    viewModel: LogViewModel,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    var selectedTab by remember { mutableIntStateOf(0) }&#10;&#10;    Column(modifier = modifier.fillMaxSize()) {&#10;        // Header&#10;        Text(&#10;            text = &quot;Kindness Log&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        )&#10;&#10;        // Tab Row&#10;        TabRow(&#10;            selectedTabIndex = selectedTab,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Tab(&#10;                selected = selectedTab == 0,&#10;                onClick = { selectedTab = 0 },&#10;                text = { Text(&quot;All Completions&quot;) }&#10;            )&#10;            Tab(&#10;                selected = selectedTab == 1,&#10;                onClick = { selectedTab = 1 },&#10;                text = { Text(&quot;Favorites&quot;) }&#10;            )&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            uiState.isLoading -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            }&#10;&#10;            uiState.error != null -&gt; {&#10;                ErrorMessage(&#10;                    error = uiState.error!!,&#10;                    onDismiss = { viewModel.clearError() }&#10;                )&#10;            }&#10;&#10;            else -&gt; {&#10;                val itemsToShow = if (selectedTab == 0) uiState.completions else uiState.favorites&#10;&#10;                if (itemsToShow.isEmpty()) {&#10;                    EmptyState(&#10;                        message = if (selectedTab == 0)&#10;                            &quot;No completed acts of kindness yet. Start your journey today!&quot;&#10;                        else&#10;                            &quot;No favorites yet. Mark your favorite acts of kindness!&quot;&#10;                    )&#10;                } else {&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentPadding = PaddingValues(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(itemsToShow) { completionWithPrompt -&gt;&#10;                            CompletionCard(&#10;                                completionWithPrompt = completionWithPrompt,&#10;                                onToggleFavorite = { viewModel.toggleFavorite(completionWithPrompt.completion) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun CompletionCard(&#10;    completionWithPrompt: CompletionWithPrompt,&#10;    onToggleFavorite: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(12.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            // Header with date and favorite button&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                val date = DateUtils.parseDateFromDatabase(completionWithPrompt.completion.completedDate)&#10;                Text(&#10;                    text = DateUtils.getRelativeDateString(date),&#10;                    style = MaterialTheme.typography.labelMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                IconButton(onClick = onToggleFavorite) {&#10;                    Icon(&#10;                        if (completionWithPrompt.completion.isFavorite)&#10;                            Icons.Default.Favorite&#10;                        else&#10;                            Icons.Default.FavoriteBorder,&#10;                        contentDescription = &quot;Toggle Favorite&quot;,&#10;                        tint = if (completionWithPrompt.completion.isFavorite)&#10;                            MaterialTheme.colorScheme.error&#10;                        else&#10;                            MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Prompt text&#10;            Text(&#10;                text = completionWithPrompt.prompt.text,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;&#10;            // Notes if available&#10;            if (completionWithPrompt.completion.notes.isNotEmpty()) {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = &quot; ${completionWithPrompt.completion.notes}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;&#10;            // Category badge&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Surface(&#10;                shape = RoundedCornerShape(16.dp),&#10;                color = MaterialTheme.colorScheme.secondaryContainer&#10;            ) {&#10;                Text(&#10;                    text = completionWithPrompt.prompt.category,&#10;                    style = MaterialTheme.typography.labelSmall,&#10;                    color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptyState(&#10;    message: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;✨&quot;,&#10;                style = MaterialTheme.typography.headlineLarge&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = message,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                textAlign = TextAlign.Center,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorMessage(&#10;    error: String,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Error&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onErrorContainer,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Text(&#10;                text = error,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onErrorContainer&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Dismiss&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>