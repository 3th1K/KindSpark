<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions for notifications --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.KindSpark&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.SplashActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Splash&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.KindSpark&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- WorkManager initialization --&gt;&#10;        &lt;provider&#10;            android:name=&quot;androidx.startup.InitializationProvider&quot;&#10;            android:authorities=&quot;${applicationId}.androidx-startup&quot;&#10;            android:exported=&quot;false&quot;&#10;            tools:node=&quot;merge&quot;&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;androidx.work.WorkManagerInitializer&quot;&#10;                android:value=&quot;androidx.startup&quot; /&gt;&#10;        &lt;/provider&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- Permissions for notifications --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.KindSpark&quot;&#13;&#10;        tools:targetApi=&quot;31&quot;&gt;&#13;&#10;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.SplashActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:theme=&quot;@style/Theme.Splash&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;        &#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:label=&quot;@string/app_name&quot;&#13;&#10;            android:theme=&quot;@style/Theme.KindSpark&quot;&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;&#13;&#10;        &lt;!-- WorkManager initialization --&gt;&#13;&#10;        &lt;provider&#13;&#10;            android:name=&quot;androidx.startup.InitializationProvider&quot;&#13;&#10;            android:authorities=&quot;${applicationId}.androidx-startup&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            tools:node=&quot;merge&quot;&gt;&#13;&#10;            &lt;meta-data&#13;&#10;                android:name=&quot;androidx.work.WorkManagerInitializer&quot;&#13;&#10;                android:value=&quot;androidx.startup&quot; /&gt;&#13;&#10;        &lt;/provider&gt;&#13;&#10;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/MainActivity.kt" />
              <option name="originalContent" value="package com.example.kindspark&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavDestination.Companion.hierarchy&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.kindspark.data.*&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import com.example.kindspark.ui.home.*&#10;import com.example.kindspark.ui.settings.*&#10;import com.example.kindspark.ui.history.*&#10;import com.example.kindspark.ui.icons.HistoryNav&#10;import com.example.kindspark.ui.theme.KindSparkAppTheme&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        // Handle the permission result if needed&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Request notification permission for Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;&#10;        setContent {&#10;            KindSparkApp()&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun KindSparkApp() {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Initialize dependencies&#10;    val database = remember { KindnessDatabase.getDatabase(context) }&#10;    val repository = remember { KindnessRepository(database.kindnessDao()) }&#10;    val userPreferencesManager = remember { UserPreferencesManager(context) }&#10;    val notificationScheduler = remember { NotificationScheduler(context, userPreferencesManager) }&#10;&#10;    // Initialize database with default prompts&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            repository.initializeDatabase()&#10;        }&#10;    }&#10;&#10;    // Create navigation controller outside of theme scope to prevent recomposition issues&#10;    val navController = rememberNavController()&#10;&#10;    // Collect theme preferences from UserPreferencesManager&#10;    val selectedTheme by userPreferencesManager.selectedTheme.collectAsStateWithLifecycle(initialValue = UserPreferencesManager.AppTheme.LIGHT)&#10;    val calmingBackground by userPreferencesManager.calmingBackground.collectAsStateWithLifecycle(initialValue = true)&#10;    val darkMode by userPreferencesManager.darkMode.collectAsStateWithLifecycle(initialValue = false)&#10;&#10;    KindSparkAppTheme(&#10;        selectedTheme = selectedTheme,&#10;        calmingBackground = calmingBackground,&#10;        darkTheme = darkMode&#10;    ) {&#10;        Scaffold(&#10;            bottomBar = {&#10;                NavigationBar {&#10;                    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;                    val currentDestination = navBackStackEntry?.destination&#10;&#10;                    bottomNavItems.forEach { screen -&gt;&#10;                        NavigationBarItem(&#10;                            icon = { Icon(screen.icon, contentDescription = screen.label) },&#10;                            label = { Text(screen.label) },&#10;                            selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,&#10;                            onClick = {&#10;                                navController.navigate(screen.route) {&#10;                                    popUpTo(navController.graph.findStartDestination().id) {&#10;                                        saveState = true&#10;                                    }&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        ) { innerPadding -&gt;&#10;            NavHost(&#10;                navController = navController,&#10;                startDestination = &quot;home&quot;,&#10;                modifier = Modifier.padding(innerPadding)&#10;            ) {&#10;                composable(&quot;home&quot;) {&#10;                    val viewModel: HomeViewModel = viewModel(&#10;                        factory = HomeViewModelFactory(&#10;                            repository,&#10;                            userPreferencesManager,&#10;                            notificationScheduler&#10;                        )&#10;                    )&#10;                    HomeScreen(viewModel = viewModel)&#10;                }&#10;&#10;                composable(&quot;history&quot;) {&#10;                    val viewModel: PromptHistoryViewModel = viewModel(&#10;                        factory = PromptHistoryViewModelFactory(repository)&#10;                    )&#10;                    PromptHistoryScreen(viewModel = viewModel)&#10;                }&#10;&#10;                composable(&quot;settings&quot;) {&#10;                    val viewModel: SettingsViewModel = viewModel(&#10;                        factory = SettingsViewModelFactory(&#10;                            userPreferencesManager,&#10;                            notificationScheduler&#10;                        )&#10;                    )&#10;                    SettingsScreen(viewModel = viewModel)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class BottomNavItem(&#10;    val route: String,&#10;    val label: String,&#10;    val icon: androidx.compose.ui.graphics.vector.ImageVector&#10;)&#10;&#10;val bottomNavItems = listOf(&#10;    BottomNavItem(&quot;home&quot;, &quot;Home&quot;, Icons.Default.Home),&#10;    BottomNavItem(&quot;history&quot;, &quot;History&quot;, Icons.Filled.HistoryNav),&#10;    BottomNavItem(&quot;settings&quot;, &quot;Settings&quot;, Icons.Default.Settings)&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.kindspark&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavDestination.Companion.hierarchy&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.kindspark.data.*&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import com.example.kindspark.ui.home.*&#10;import com.example.kindspark.ui.settings.*&#10;import com.example.kindspark.ui.history.*&#10;import com.example.kindspark.ui.icons.HistoryNav&#10;import com.example.kindspark.ui.theme.KindSparkAppTheme&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        // Handle the permission result if needed&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Request notification permission for Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) != PackageManager.PERMISSION_GRANTED&#10;            ) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;&#10;        setContent {&#10;            KindSparkApp()&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun KindSparkApp() {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Initialize dependencies&#10;    val database = remember { KindnessDatabase.getDatabase(context) }&#10;    val repository = remember { KindnessRepository(database.kindnessDao()) }&#10;    val userPreferencesManager = remember { UserPreferencesManager(context) }&#10;    val notificationScheduler = remember { NotificationScheduler(context, userPreferencesManager) }&#10;&#10;    // Initialize database with default prompts&#10;    LaunchedEffect(Unit) {&#10;        coroutineScope.launch {&#10;            repository.initializeDatabase()&#10;        }&#10;    }&#10;&#10;    // Create navigation controller outside of theme scope to prevent recomposition issues&#10;    val navController = rememberNavController()&#10;&#10;    // Collect theme preferences from UserPreferencesManager&#10;    val selectedTheme by userPreferencesManager.selectedTheme.collectAsStateWithLifecycle(initialValue = UserPreferencesManager.AppTheme.LIGHT)&#10;    val calmingBackground by userPreferencesManager.calmingBackground.collectAsStateWithLifecycle(initialValue = true)&#10;    val darkMode by userPreferencesManager.darkMode.collectAsStateWithLifecycle(initialValue = false)&#10;&#10;    KindSparkAppTheme(&#10;        selectedTheme = selectedTheme,&#10;        calmingBackground = calmingBackground,&#10;        darkTheme = darkMode&#10;    ) {&#10;        Scaffold(&#10;            bottomBar = {&#10;                NavigationBar {&#10;                    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;                    val currentDestination = navBackStackEntry?.destination&#10;&#10;                    bottomNavItems.forEach { screen -&gt;&#10;                        NavigationBarItem(&#10;                            icon = { Icon(screen.icon, contentDescription = screen.label) },&#10;                            label = { Text(screen.label) },&#10;                            selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,&#10;                            onClick = {&#10;                                navController.navigate(screen.route) {&#10;                                    popUpTo(navController.graph.findStartDestination().id) {&#10;                                        saveState = true&#10;                                    }&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        ) { innerPadding -&gt;&#10;            NavHost(&#10;                navController = navController,&#10;                startDestination = &quot;home&quot;,&#10;                modifier = Modifier.padding(innerPadding)&#10;            ) {&#10;                composable(&quot;home&quot;) {&#10;                    val viewModel: HomeViewModel = viewModel(&#10;                        factory = HomeViewModelFactory(&#10;                            repository,&#10;                            userPreferencesManager,&#10;                            notificationScheduler&#10;                        )&#10;                    )&#10;                    HomeScreen(viewModel = viewModel)&#10;                }&#10;&#10;                composable(&quot;history&quot;) {&#10;                    val viewModel: PromptHistoryViewModel = viewModel(&#10;                        factory = PromptHistoryViewModelFactory(repository)&#10;                    )&#10;                    PromptHistoryScreen(viewModel = viewModel)&#10;                }&#10;&#10;                composable(&quot;settings&quot;) {&#10;                    val viewModel: SettingsViewModel = viewModel(&#10;                        factory = SettingsViewModelFactory(&#10;                            userPreferencesManager,&#10;                            notificationScheduler&#10;                        )&#10;                    )&#10;                    SettingsScreen(viewModel = viewModel)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class BottomNavItem(&#10;    val route: String,&#10;    val label: String,&#10;    val icon: androidx.compose.ui.graphics.vector.ImageVector&#10;)&#10;&#10;val bottomNavItems = listOf(&#10;    BottomNavItem(&quot;home&quot;, &quot;Home&quot;, Icons.Default.Home),&#10;    BottomNavItem(&quot;history&quot;, &quot;History&quot;, Icons.Filled.HistoryNav),&#10;    BottomNavItem(&quot;settings&quot;, &quot;Settings&quot;, Icons.Default.Settings)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/SplashActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/SplashActivity.kt" />
              <option name="originalContent" value="package com.example.kindspark&#10;&#10;import android.R&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import androidx.appcompat.app.AppCompatActivity&#10;&#10;class SplashActivity : AppCompatActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        Handler(Looper.getMainLooper()).postDelayed({&#10;            startActivity(Intent(this, MainActivity::class.java))&#10;            overridePendingTransition(R.anim.fade_in, R.anim.fade_out)&#10;            finish()&#10;        }, 800) // Show splash for 800ms&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.kindspark&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.appcompat.app.AppCompatActivity&#10;&#10;class SplashActivity : AppCompatActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Ensure the activity is properly initialized before proceeding&#10;        Handler(Looper.getMainLooper()).postDelayed({&#10;            try {&#10;                // Check if activity is still valid before starting MainActivity&#10;                if (!isFinishing &amp;&amp; !isDestroyed) {&#10;                    val intent = Intent(this, MainActivity::class.java)&#10;                    // Add flags to ensure proper task management&#10;                    intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                    startActivity(intent)&#10;                    finish()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SplashActivity&quot;, &quot;Error starting MainActivity&quot;, e)&#10;                // Fallback: try again with a longer delay&#10;                Handler(Looper.getMainLooper()).postDelayed({&#10;                    try {&#10;                        if (!isFinishing &amp;&amp; !isDestroyed) {&#10;                            val intent = Intent(this, MainActivity::class.java)&#10;                            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                            startActivity(intent)&#10;                            finish()&#10;                        }&#10;                    } catch (ex: Exception) {&#10;                        Log.e(&quot;SplashActivity&quot;, &quot;Critical error starting MainActivity&quot;, ex)&#10;                    }&#10;                }, 1000)&#10;            }&#10;        }, 1500) // Increased delay to 1.5 seconds for better stability&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        // Remove any pending callbacks to prevent memory leaks&#10;        Handler(Looper.getMainLooper()).removeCallbacksAndMessages(null)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessDatabase.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [KindnessPrompt::class, KindnessCompletion::class, SkippedPrompt::class, UserProgress::class, DailyPromptSelection::class],&#10;    version = 4,&#10;    exportSchema = false&#10;)&#10;abstract class KindnessDatabase : RoomDatabase() {&#10;&#10;    abstract fun kindnessDao(): KindnessPromptDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: KindnessDatabase? = null&#10;&#10;        fun getDatabase(context: Context): KindnessDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    KindnessDatabase::class.java,&#10;                    &quot;kindness_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [KindnessPrompt::class, KindnessCompletion::class, SkippedPrompt::class, UserProgress::class, DailyPromptSelection::class],&#10;    version = 4,&#10;    exportSchema = false&#10;)&#10;abstract class KindnessDatabase : RoomDatabase() {&#10;&#10;    abstract fun kindnessDao(): KindnessPromptDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: KindnessDatabase? = null&#10;&#10;        fun getDatabase(context: Context): KindnessDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    KindnessDatabase::class.java,&#10;                    &quot;kindness_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPrompt.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPrompt.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import java.time.LocalDate&#10;&#10;@Entity(tableName = &quot;kindness_prompts&quot;)&#10;data class KindnessPrompt(&#10;    @PrimaryKey val id: Int,&#10;    val text: String,&#10;    val category: String = &quot;general&quot;&#10;)&#10;&#10;@Entity(tableName = &quot;kindness_completions&quot;)&#10;data class KindnessCompletion(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val promptId: Int,&#10;    val completedDate: String, // Using String to store LocalDate as YYYY-MM-DD&#10;    val isFavorite: Boolean = false,&#10;    val notes: String = &quot;&quot;&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#13;&#10;&#13;&#10;import androidx.room.Entity&#13;&#10;import androidx.room.PrimaryKey&#13;&#10;import java.time.LocalDate&#13;&#10;&#13;&#10;@Entity(tableName = &quot;kindness_prompts&quot;)&#13;&#10;data class KindnessPrompt(&#13;&#10;    @PrimaryKey val id: Int,&#13;&#10;    val text: String,&#13;&#10;    val category: String = &quot;general&quot;&#13;&#10;)&#13;&#10;&#13;&#10;@Entity(tableName = &quot;kindness_completions&quot;)&#13;&#10;data class KindnessCompletion(&#13;&#10;    @PrimaryKey(autoGenerate = true)&#13;&#10;    val id: Long = 0,&#13;&#10;    val promptId: Int,&#13;&#10;    val completedDate: String, // Using String to store LocalDate as YYYY-MM-DD&#13;&#10;    val isFavorite: Boolean = false,&#13;&#10;    val notes: String = &quot;&quot;&#13;&#10;)&#13;&#10;&#13;&#10;@Entity(tableName = &quot;skipped_prompts&quot;)&#13;&#10;data class SkippedPrompt(&#13;&#10;    @PrimaryKey(autoGenerate = true)&#13;&#10;    val id: Long = 0,&#13;&#10;    val promptId: Int,&#13;&#10;    val skippedDate: String, // Using String to store LocalDate as YYYY-MM-DD&#13;&#10;    val reason: String = &quot;&quot; // Optional reason for skipping&#13;&#10;)&#13;&#10;&#13;&#10;@Entity(tableName = &quot;daily_prompt_selection&quot;)&#13;&#10;data class DailyPromptSelection(&#13;&#10;    @PrimaryKey&#13;&#10;    val date: String, // YYYY-MM-DD format&#13;&#10;    val promptId: Int&#13;&#10;)&#13;&#10;&#13;&#10;data class KindnessPromptWithCompletion(&#13;&#10;    val prompt: KindnessPrompt,&#13;&#10;    val completion: KindnessCompletion?&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPromptDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessPromptDao.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface KindnessPromptDao {&#10;&#10;    @Query(&quot;SELECT * FROM kindness_prompts&quot;)&#10;    suspend fun getAllPrompts(): List&lt;KindnessPrompt&gt;&#10;&#10;    @Query(&quot;SELECT * FROM kindness_prompts WHERE id = :id&quot;)&#10;    suspend fun getPromptById(id: Int): KindnessPrompt?&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions ORDER BY completedDate DESC&quot;)&#10;    fun getAllCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE completedDate = :date&quot;)&#10;    suspend fun getCompletionByDate(date: String): KindnessCompletion?&#10;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE isFavorite = 1 ORDER BY completedDate DESC&quot;)&#10;    fun getFavoriteCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.IGNORE)&#10;    suspend fun insertPrompts(prompts: List&lt;KindnessPrompt&gt;)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertCompletion(completion: KindnessCompletion): Long&#10;&#10;    @Update&#10;    suspend fun updateCompletion(completion: KindnessCompletion)&#10;&#10;    @Delete&#10;    suspend fun deleteCompletion(completion: KindnessCompletion)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_completions WHERE completedDate BETWEEN :startDate AND :endDate&quot;)&#10;    suspend fun getCompletionCountBetweenDates(startDate: String, endDate: String): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_prompts&quot;)&#10;    suspend fun getPromptCount(): Int&#10;&#10;    // Skipped prompts methods&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertSkippedPrompt(skippedPrompt: SkippedPrompt): Long&#10;&#10;    @Query(&quot;SELECT * FROM skipped_prompts WHERE skippedDate = :date&quot;)&#10;    suspend fun getSkippedPromptsByDate(date: String): List&lt;SkippedPrompt&gt;&#10;&#10;    @Query(&quot;SELECT promptId FROM skipped_prompts WHERE skippedDate = :date&quot;)&#10;    suspend fun getSkippedPromptIdsByDate(date: String): List&lt;Int&gt;&#10;&#10;    @Query(&quot;DELETE FROM skipped_prompts WHERE skippedDate &lt; :cutoffDate&quot;)&#10;    suspend fun deleteOldSkippedPrompts(cutoffDate: String)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#13;&#10;&#13;&#10;import androidx.room.*&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;&#13;&#10;@Dao&#13;&#10;interface KindnessPromptDao {&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM kindness_prompts&quot;)&#13;&#10;    suspend fun getAllPrompts(): List&lt;KindnessPrompt&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM kindness_prompts WHERE id = :id&quot;)&#13;&#10;    suspend fun getPromptById(id: Int): KindnessPrompt?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM kindness_completions ORDER BY completedDate DESC&quot;)&#13;&#10;    fun getAllCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE completedDate = :date&quot;)&#13;&#10;    suspend fun getCompletionByDate(date: String): KindnessCompletion?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM kindness_completions WHERE isFavorite = 1 ORDER BY completedDate DESC&quot;)&#13;&#10;    fun getFavoriteCompletions(): Flow&lt;List&lt;KindnessCompletion&gt;&gt;&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.IGNORE)&#13;&#10;    suspend fun insertPrompts(prompts: List&lt;KindnessPrompt&gt;)&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertCompletion(completion: KindnessCompletion): Long&#13;&#10;&#13;&#10;    @Update&#13;&#10;    suspend fun updateCompletion(completion: KindnessCompletion)&#13;&#10;&#13;&#10;    @Delete&#13;&#10;    suspend fun deleteCompletion(completion: KindnessCompletion)&#13;&#10;&#13;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_completions WHERE completedDate BETWEEN :startDate AND :endDate&quot;)&#13;&#10;    suspend fun getCompletionCountBetweenDates(startDate: String, endDate: String): Int&#13;&#10;&#13;&#10;    @Query(&quot;SELECT COUNT(*) FROM kindness_prompts&quot;)&#13;&#10;    suspend fun getPromptCount(): Int&#13;&#10;&#13;&#10;    // Skipped prompts methods&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertSkippedPrompt(skippedPrompt: SkippedPrompt): Long&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM skipped_prompts WHERE skippedDate = :date&quot;)&#13;&#10;    suspend fun getSkippedPromptsByDate(date: String): List&lt;SkippedPrompt&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT promptId FROM skipped_prompts WHERE skippedDate = :date&quot;)&#13;&#10;    suspend fun getSkippedPromptIdsByDate(date: String): List&lt;Int&gt;&#13;&#10;&#13;&#10;    @Query(&quot;DELETE FROM skipped_prompts WHERE skippedDate &lt; :cutoffDate&quot;)&#13;&#10;    suspend fun deleteOldSkippedPrompts(cutoffDate: String)&#13;&#10;&#13;&#10;    // UserProgress methods&#13;&#10;    @Query(&quot;SELECT * FROM user_progress WHERE id = 1&quot;)&#13;&#10;    suspend fun getUserProgress(): UserProgress?&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertOrUpdateUserProgress(userProgress: UserProgress)&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE user_progress SET currentStreak = :streak, lastCompletedDate = :date WHERE id = 1&quot;)&#13;&#10;    suspend fun updateStreak(streak: Int, date: String)&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE user_progress SET bestStreak = :bestStreak WHERE id = 1&quot;)&#13;&#10;    suspend fun updateBestStreak(bestStreak: Int)&#13;&#10;&#13;&#10;    // Daily prompt selection methods&#13;&#10;    @Query(&quot;SELECT * FROM daily_prompt_selection WHERE date = :date&quot;)&#13;&#10;    suspend fun getDailyPromptSelection(date: String): DailyPromptSelection?&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertDailyPromptSelection(selection: DailyPromptSelection)&#13;&#10;&#13;&#10;    @Query(&quot;DELETE FROM daily_prompt_selection WHERE date &lt; :cutoffDate&quot;)&#13;&#10;    suspend fun deleteOldDailyPromptSelections(cutoffDate: String)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/KindnessRepository.kt" />
              <option name="originalContent" value="package com.example.kindspark.data&#10;&#10;import kotlinx.coroutines.flow.Flow&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import kotlin.random.Random&#10;&#10;class KindnessRepository(private val dao: KindnessPromptDao) {&#10;&#10;    private val dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)&#10;&#10;    // Pre-defined kindness prompts&#10;    private val defaultPrompts = listOf(&#10;        KindnessPrompt(1, &quot;Compliment someone genuinely.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(2, &quot;Call or text a family member to check on them.&quot;, &quot;family&quot;),&#10;        KindnessPrompt(3, &quot;Help a stranger today in any small way.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(4, &quot;Leave a positive comment on social media.&quot;, &quot;digital&quot;),&#10;        KindnessPrompt(5, &quot;Pick up litter you see on the ground.&quot;, &quot;environment&quot;),&#10;        KindnessPrompt(6, &quot;Support a local business with kind words or a review.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(7, &quot;Hold the door open for someone.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(8, &quot;Write a short thank-you note to someone.&quot;, &quot;gratitude&quot;),&#10;        KindnessPrompt(9, &quot;Donate clothes or items you no longer need.&quot;, &quot;charity&quot;),&#10;        KindnessPrompt(10, &quot;Smile at a stranger and say hello.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(11, &quot;Let someone go ahead of you in line.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(12, &quot;Offer to help a coworker with their tasks.&quot;, &quot;workplace&quot;),&#10;        KindnessPrompt(13, &quot;Send an encouraging message to a friend.&quot;, &quot;friendship&quot;),&#10;        KindnessPrompt(14, &quot;Pay for someone's coffee or meal.&quot;, &quot;generosity&quot;),&#10;        KindnessPrompt(15, &quot;Volunteer for a local charity or cause.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(16, &quot;Listen actively to someone who needs to talk.&quot;, &quot;empathy&quot;),&#10;        KindnessPrompt(17, &quot;Forgive someone who has wronged you.&quot;, &quot;forgiveness&quot;),&#10;        KindnessPrompt(18, &quot;Share your knowledge or skills with others.&quot;, &quot;teaching&quot;),&#10;        KindnessPrompt(19, &quot;Give a genuine compliment to a service worker.&quot;, &quot;appreciation&quot;),&#10;        KindnessPrompt(20, &quot;Plant a flower or tree in your community.&quot;, &quot;environment&quot;)&#10;    )&#10;&#10;    suspend fun initializeDatabase() {&#10;        val promptCount = dao.getPromptCount()&#10;        if (promptCount == 0) {&#10;            dao.insertPrompts(defaultPrompts)&#10;        }&#10;    }&#10;&#10;    suspend fun getDailyPrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;&#10;        // Check if there's already a completion for today&#10;        val existingCompletion = dao.getCompletionByDate(dateString)&#10;&#10;        if (existingCompletion != null) {&#10;            // Return the prompt that was already completed today&#10;            val prompt = dao.getPromptById(existingCompletion.promptId)&#10;            return KindnessPromptWithCompletion(prompt!!, existingCompletion)&#10;        }&#10;&#10;        var currentDate = today&#10;        var currentDate = today&#10;    suspend fun markPromptAsCompleted(promptId: Int, date: LocalDate = LocalDate.now(), notes: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;        val today = LocalDate.now()&#10;        var currentDate = today&#10;        var currentDate = today&#10;                currentDate = currentDate.minusDays(1)&#10;            val dateString = currentDate.format(dateFormatter)&#10;                currentDate = currentDate.minusDays(1)&#10;            val dateString = currentDate.format(dateFormatter)&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;        val seed = date.toEpochDay()&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: LocalDate): KindnessPromptWithCompletion {&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;            val calendar = Calendar.getInstance()&#10;            calendar.time = lastDate&#10;            calendar.add(Calendar.DAY_OF_MONTH, 1) // Add one day to last date&#10;&#10;&#10;    suspend fun getStreakMilestones(currentStreak: Int): List&lt;Int&gt; {&#10;        // Return milestone numbers that were just reached&#10;        val milestones = listOf(3, 7, 14, 21, 30, 50, 100)&#10;        return milestones.filter { milestone -&gt;&#10;            currentStreak == milestone&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import kotlinx.coroutines.flow.Flow&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import kotlin.random.Random&#10;&#10;class KindnessRepository(private val dao: KindnessPromptDao) {&#10;&#10;    private val dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)&#10;&#10;    // Pre-defined kindness prompts&#10;    private val defaultPrompts = listOf(&#10;        KindnessPrompt(1, &quot;Compliment someone genuinely.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(2, &quot;Call or text a family member to check on them.&quot;, &quot;family&quot;),&#10;        KindnessPrompt(3, &quot;Help a stranger today in any small way.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(4, &quot;Leave a positive comment on social media.&quot;, &quot;digital&quot;),&#10;        KindnessPrompt(5, &quot;Pick up litter you see on the ground.&quot;, &quot;environment&quot;),&#10;        KindnessPrompt(6, &quot;Support a local business with kind words or a review.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(7, &quot;Hold the door open for someone.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(8, &quot;Write a short thank-you note to someone.&quot;, &quot;gratitude&quot;),&#10;        KindnessPrompt(9, &quot;Donate clothes or items you no longer need.&quot;, &quot;charity&quot;),&#10;        KindnessPrompt(10, &quot;Smile at a stranger and say hello.&quot;, &quot;social&quot;),&#10;        KindnessPrompt(11, &quot;Let someone go ahead of you in line.&quot;, &quot;courtesy&quot;),&#10;        KindnessPrompt(12, &quot;Offer to help a coworker with their tasks.&quot;, &quot;workplace&quot;),&#10;        KindnessPrompt(13, &quot;Send an encouraging message to a friend.&quot;, &quot;friendship&quot;),&#10;        KindnessPrompt(14, &quot;Pay for someone's coffee or meal.&quot;, &quot;generosity&quot;),&#10;        KindnessPrompt(15, &quot;Volunteer for a local charity or cause.&quot;, &quot;community&quot;),&#10;        KindnessPrompt(16, &quot;Listen actively to someone who needs to talk.&quot;, &quot;empathy&quot;),&#10;        KindnessPrompt(17, &quot;Forgive someone who has wronged you.&quot;, &quot;forgiveness&quot;),&#10;        KindnessPrompt(18, &quot;Share your knowledge or skills with others.&quot;, &quot;teaching&quot;),&#10;        KindnessPrompt(19, &quot;Give a genuine compliment to a service worker.&quot;, &quot;appreciation&quot;),&#10;        KindnessPrompt(20, &quot;Plant a flower or tree in your community.&quot;, &quot;environment&quot;)&#10;    )&#10;&#10;    suspend fun initializeDatabase() {&#10;        val promptCount = dao.getPromptCount()&#10;        if (promptCount == 0) {&#10;            dao.insertPrompts(defaultPrompts)&#10;        }&#10;    }&#10;&#10;    suspend fun getDailyPrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;&#10;        // Check if there's already a completion for today&#10;        val existingCompletion = dao.getCompletionByDate(dateString)&#10;&#10;        if (existingCompletion != null) {&#10;            // Return the prompt that was already completed today&#10;            val prompt = dao.getPromptById(existingCompletion.promptId)&#10;            return KindnessPromptWithCompletion(prompt!!, existingCompletion)&#10;        }&#10;&#10;        var currentDate = today&#10;        var currentDate = today&#10;    suspend fun markPromptAsCompleted(promptId: Int, date: LocalDate = LocalDate.now(), notes: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;        val today = LocalDate.now()&#10;        var currentDate = today&#10;        var currentDate = today&#10;                currentDate = currentDate.minusDays(1)&#10;            val dateString = currentDate.format(dateFormatter)&#10;                currentDate = currentDate.minusDays(1)&#10;            val dateString = currentDate.format(dateFormatter)&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;                currentDate = currentDate.minusDays(1)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun skipPrompt(promptId: Int, date: LocalDate = LocalDate.now(), reason: String = &quot;&quot;): Long {&#10;        val dateString = date.format(dateFormatter)&#10;        val seed = date.toEpochDay()&#10;    private fun getRandomPromptFromAll(allPrompts: List&lt;KindnessPrompt&gt;, date: LocalDate): KindnessPromptWithCompletion {&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;    suspend fun getNextAvailablePrompt(date: LocalDate = LocalDate.now()): KindnessPromptWithCompletion {&#10;        val dateString = date.format(dateFormatter)&#10;        val cutoffDate = LocalDate.now().minusDays(daysToKeep.toLong())&#10;        val seed = date.toEpochDay() + skippedTodayIds.size&#10;            val calendar = Calendar.getInstance()&#10;            calendar.time = lastDate&#10;            calendar.add(Calendar.DAY_OF_MONTH, 1) // Add one day to last date&#10;&#10;&#10;    suspend fun getStreakMilestones(currentStreak: Int): List&lt;Int&gt; {&#10;        // Return milestone numbers that were just reached&#10;        val milestones = listOf(3, 7, 14, 21, 30, 50, 100)&#10;        return milestones.filter { milestone -&gt;&#10;            currentStreak == milestone&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/UserProgress.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/UserProgress.kt" />
              <option name="updatedContent" value="package com.example.kindspark.data&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;user_progress&quot;)&#10;data class UserProgress(&#10;    @PrimaryKey val id: Int = 1, // Single row for user progress&#10;    val currentStreak: Int = 0,&#10;    val bestStreak: Int = 0,&#10;    val lastCompletedDate: String = &quot;&quot;, // YYYY-MM-DD format&#10;    val totalCompleted: Int = 0,&#10;    val startDate: String = &quot;&quot; // When user first started using the app&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/preferences/UserPreferencesManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/data/preferences/UserPreferencesManager.kt" />
              <option name="originalContent" value="package com.example.kindspark.data.preferences&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.*&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;private val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;user_preferences&quot;)&#10;&#10;class UserPreferencesManager(private val context: Context) {&#10;&#10;    companion object {&#10;        private val NOTIFICATION_INTERVAL_KEY = intPreferencesKey(&quot;notification_interval&quot;)&#10;        private val NOTIFICATION_ENABLED_KEY = booleanPreferencesKey(&quot;notification_enabled&quot;)&#10;        private val NOTIFICATION_SOUND_KEY = booleanPreferencesKey(&quot;notification_sound&quot;)&#10;        private val DARK_MODE_KEY = booleanPreferencesKey(&quot;dark_mode&quot;)&#10;        private val SELECTED_THEME_KEY = stringPreferencesKey(&quot;selected_theme&quot;)&#10;        private val CALMING_BACKGROUND_KEY = booleanPreferencesKey(&quot;calming_background&quot;)&#10;        private val LOTTIE_ANIMATIONS_KEY = booleanPreferencesKey(&quot;lottie_animations&quot;)&#10;    }&#10;&#10;    enum class NotificationInterval(val hours: Int, val displayName: String) {&#10;        ONCE_DAILY(24, &quot;Once Daily&quot;),&#10;        EVERY_6_HOURS(6, &quot;Every 6 Hours&quot;),&#10;        EVERY_3_HOURS(3, &quot;Every 3 Hours&quot;),&#10;        EVERY_HOUR(1, &quot;Every Hour&quot;)&#10;    }&#10;&#10;    enum class AppTheme(val displayName: String) {&#10;        LIGHT(&quot;Light&quot;),&#10;        DARK(&quot;Dark&quot;),&#10;        SOFT_BLUE(&quot;Soft Blue&quot;),&#10;        SOFT_GREEN(&quot;Soft Green&quot;)&#10;&#10;    val darkMode: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[DARK_MODE_KEY] ?: false&#10;    }&#10;&#10;    val selectedTheme: Flow&lt;AppTheme&gt; = context.dataStore.data.map { preferences -&gt;&#10;        val themeName = preferences[SELECTED_THEME_KEY] ?: &quot;LIGHT&quot;&#10;        AppTheme.values().find { it.name == themeName } ?: AppTheme.LIGHT&#10;    }&#10;&#10;    val calmingBackground: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[CALMING_BACKGROUND_KEY] ?: true&#10;    }&#10;&#10;    val lottieAnimations: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[LOTTIE_ANIMATIONS_KEY] ?: true&#10;    }&#10;&#10;    suspend fun updateNotificationInterval(interval: NotificationInterval) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_INTERVAL_KEY] = interval.hours&#10;        }&#10;    }&#10;&#10;    suspend fun updateNotificationEnabled(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_ENABLED_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateNotificationSound(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_SOUND_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateDarkMode(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[DARK_MODE_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateSelectedTheme(theme: AppTheme) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[SELECTED_THEME_KEY] = theme.name&#10;        }&#10;    }&#10;&#10;    suspend fun updateCalmingBackground(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[CALMING_BACKGROUND_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateLottieAnimations(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[LOTTIE_ANIMATIONS_KEY] = enabled&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.data.preferences&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.*&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;private val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;user_preferences&quot;)&#10;&#10;class UserPreferencesManager(private val context: Context) {&#10;&#10;    companion object {&#10;        private val NOTIFICATION_INTERVAL_KEY = intPreferencesKey(&quot;notification_interval&quot;)&#10;        private val NOTIFICATION_ENABLED_KEY = booleanPreferencesKey(&quot;notification_enabled&quot;)&#10;        private val NOTIFICATION_SOUND_KEY = booleanPreferencesKey(&quot;notification_sound&quot;)&#10;        private val DARK_MODE_KEY = booleanPreferencesKey(&quot;dark_mode&quot;)&#10;        private val SELECTED_THEME_KEY = stringPreferencesKey(&quot;selected_theme&quot;)&#10;        private val CALMING_BACKGROUND_KEY = booleanPreferencesKey(&quot;calming_background&quot;)&#10;        private val LOTTIE_ANIMATIONS_KEY = booleanPreferencesKey(&quot;lottie_animations&quot;)&#10;    }&#10;&#10;    enum class NotificationInterval(val hours: Int, val displayName: String) {&#10;        ONCE_DAILY(24, &quot;Once Daily&quot;),&#10;        EVERY_6_HOURS(6, &quot;Every 6 Hours&quot;),&#10;        EVERY_3_HOURS(3, &quot;Every 3 Hours&quot;),&#10;        EVERY_HOUR(1, &quot;Every Hour&quot;)&#10;    }&#10;&#10;    enum class AppTheme(val displayName: String) {&#10;        LIGHT(&quot;Light&quot;),&#10;        DARK(&quot;Dark&quot;),&#10;        CALM_OCEAN(&quot;Calm Ocean&quot;),&#10;        WARM_SUNSET(&quot;Warm Sunset&quot;),&#10;        SERENE_FOREST(&quot;Serene Forest&quot;),&#10;        MIDNIGHT_CALM(&quot;Midnight Calm&quot;)&#10;    }&#10;&#10;    val notificationInterval: Flow&lt;NotificationInterval&gt; = context.dataStore.data.map { preferences -&gt;&#10;        val hours = preferences[NOTIFICATION_INTERVAL_KEY] ?: 24&#10;        NotificationInterval.values().find { it.hours == hours } ?: NotificationInterval.ONCE_DAILY&#10;    }&#10;&#10;    val notificationEnabled: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[NOTIFICATION_ENABLED_KEY] ?: true&#10;    }&#10;&#10;    val notificationSound: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[NOTIFICATION_SOUND_KEY] ?: true&#10;    }&#10;&#10;    val darkMode: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[DARK_MODE_KEY] ?: false&#10;    }&#10;&#10;    val selectedTheme: Flow&lt;AppTheme&gt; = context.dataStore.data.map { preferences -&gt;&#10;        val themeName = preferences[SELECTED_THEME_KEY] ?: &quot;LIGHT&quot;&#10;        AppTheme.values().find { it.name == themeName } ?: AppTheme.LIGHT&#10;    }&#10;&#10;    val calmingBackground: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[CALMING_BACKGROUND_KEY] ?: true&#10;    }&#10;&#10;    val lottieAnimations: Flow&lt;Boolean&gt; = context.dataStore.data.map { preferences -&gt;&#10;        preferences[LOTTIE_ANIMATIONS_KEY] ?: true&#10;    }&#10;&#10;    suspend fun updateNotificationInterval(interval: NotificationInterval) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_INTERVAL_KEY] = interval.hours&#10;        }&#10;    }&#10;&#10;    suspend fun updateNotificationEnabled(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_ENABLED_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateNotificationSound(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[NOTIFICATION_SOUND_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateDarkMode(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[DARK_MODE_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateSelectedTheme(theme: AppTheme) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[SELECTED_THEME_KEY] = theme.name&#10;        }&#10;    }&#10;&#10;    suspend fun updateCalmingBackground(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[CALMING_BACKGROUND_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun updateLottieAnimations(enabled: Boolean) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences[LOTTIE_ANIMATIONS_KEY] = enabled&#10;        }&#10;    }&#10;&#10;    suspend fun resetToDefaults() {&#10;        context.dataStore.edit { preferences -&gt;&#10;            preferences.clear()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/components/HistoryComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/components/HistoryComponents.kt" />
              <option name="updatedContent" value="package com.example.kindspark.ui.components&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.example.kindspark.data.KindnessCompletion&#10;import com.example.kindspark.data.KindnessPrompt&#10;import com.example.kindspark.ui.history.HistoryFilter&#10;import com.example.kindspark.ui.icons.SparklingHeart&#10;import com.example.kindspark.ui.icons.CustomHistoryEdu&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;&#10;@Composable&#10;fun PromptHistoryCard(&#10;    prompt: KindnessPrompt,&#10;    completion: KindnessCompletion,&#10;    onFavoriteToggle: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp)&#10;        ) {&#10;            // Header with date and favorite button&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Date&#10;                Text(&#10;                    text = formatCompletionDate(completion.completedDate),&#10;                    style = MaterialTheme.typography.labelMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                // Favorite button&#10;                FavoriteButton(&#10;                    isFavorite = completion.isFavorite,&#10;                    onClick = onFavoriteToggle&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Prompt text&#10;            Text(&#10;                text = prompt.text,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface,&#10;                fontWeight = FontWeight.Medium,&#10;                lineHeight = MaterialTheme.typography.bodyLarge.lineHeight&#10;            )&#10;&#10;            // Category tag if available&#10;            if (prompt.category.isNotBlank()) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;                CategoryTag(category = prompt.category)&#10;            }&#10;&#10;            // Notes if available&#10;            if (completion.notes.isNotBlank()) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;                Text(&#10;                    text = &quot;\&quot;${completion.notes}\&quot;&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    fontStyle = androidx.compose.ui.text.font.FontStyle.Italic&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FavoriteButton(&#10;    isFavorite: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val scale by animateFloatAsState(&#10;        targetValue = if (isFavorite) 1.2f else 1.0f,&#10;        animationSpec = spring(&#10;            dampingRatio = Spring.DampingRatioMediumBouncy,&#10;            stiffness = Spring.StiffnessLow&#10;        ),&#10;        label = &quot;favorite_scale&quot;&#10;    )&#10;&#10;    IconButton(&#10;        onClick = onClick,&#10;        modifier = modifier&#10;    ) {&#10;        Icon(&#10;            imageVector = if (isFavorite) Icons.Outlined.SparklingHeart else Icons.Default.FavoriteBorder,&#10;            contentDescription = if (isFavorite) &quot;Remove from favorites&quot; else &quot;Add to favorites&quot;,&#10;            tint = if (isFavorite) {&#10;                Color(0xFFE91E63) // Pink color for favorited items&#10;            } else {&#10;                MaterialTheme.colorScheme.onSurfaceVariant&#10;            },&#10;            modifier = Modifier.scale(scale)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CategoryTag(&#10;    category: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val categoryColor = getCategoryColor(category)&#10;&#10;    Surface(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(12.dp),&#10;        color = categoryColor.copy(alpha = 0.1f)&#10;    ) {&#10;        Text(&#10;            text = category.replaceFirstChar { it.uppercaseChar() },&#10;            style = MaterialTheme.typography.labelSmall,&#10;            color = categoryColor,&#10;            fontWeight = FontWeight.Medium,&#10;            modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HistoryFilterChips(&#10;    currentFilter: HistoryFilter,&#10;    onFilterChange: (HistoryFilter) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        HistoryFilter.values().forEach { filter -&gt;&#10;            FilterChip(&#10;                selected = currentFilter == filter,&#10;                onClick = { onFilterChange(filter) },&#10;                label = {&#10;                    Text(&#10;                        text = when (filter) {&#10;                            HistoryFilter.ALL -&gt; &quot;All&quot;&#10;                            HistoryFilter.COMPLETED -&gt; &quot;Completed&quot;&#10;                            HistoryFilter.FAVORITES -&gt; &quot;Favorites&quot;&#10;                        },&#10;                        fontWeight = if (currentFilter == filter) FontWeight.SemiBold else FontWeight.Medium&#10;                    )&#10;                },&#10;                leadingIcon = if (currentFilter == filter) {&#10;                    {&#10;                        Icon(&#10;                            imageVector = when (filter) {&#10;                                HistoryFilter.ALL -&gt; Icons.Default.List&#10;                                HistoryFilter.COMPLETED -&gt; Icons.Default.CheckCircle&#10;                                HistoryFilter.FAVORITES -&gt; Icons.Default.Favorite&#10;                            },&#10;                            contentDescription = null,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                    }&#10;                } else null,&#10;                colors = FilterChipDefaults.filterChipColors(&#10;                    selectedContainerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    selectedLabelColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyHistoryState(&#10;    filter: HistoryFilter,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(48.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Empty state icon&#10;        Box(&#10;            modifier = Modifier&#10;                .size(120.dp)&#10;                .background(&#10;                    brush = Brush.radialGradient(&#10;                        colors = listOf(&#10;                            MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f),&#10;                            MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.1f)&#10;                        )&#10;                    ),&#10;                    shape = CircleShape&#10;                ),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Icon(&#10;                imageVector = when (filter) {&#10;                    HistoryFilter.ALL -&gt; Icons.Filled.CustomHistoryEdu&#10;                    HistoryFilter.COMPLETED -&gt; Icons.Default.CheckCircle&#10;                    HistoryFilter.FAVORITES -&gt; Icons.Default.Favorite&#10;                },&#10;                contentDescription = null,&#10;                modifier = Modifier.size(48.dp),&#10;                tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        Text(&#10;            text = when (filter) {&#10;                HistoryFilter.ALL -&gt; &quot;No prompts completed yet&quot;&#10;                HistoryFilter.COMPLETED -&gt; &quot;No completed prompts&quot;&#10;                HistoryFilter.FAVORITES -&gt; &quot;No favorite prompts yet&quot;&#10;            },&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            fontWeight = FontWeight.SemiBold,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Text(&#10;            text = when (filter) {&#10;                HistoryFilter.ALL -&gt; &quot;Start completing daily kindness prompts to see them here&quot;&#10;                HistoryFilter.COMPLETED -&gt; &quot;Complete some kindness prompts to see them here&quot;&#10;                HistoryFilter.FAVORITES -&gt; &quot;Mark prompts as favorites by tapping the heart icon&quot;&#10;            },&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;// Helper functions&#10;private fun formatCompletionDate(dateString: String): String {&#10;    return try {&#10;        val date = LocalDate.parse(dateString)&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;MMM d, yyyy&quot;)&#10;        date.format(formatter)&#10;    } catch (e: Exception) {&#10;        dateString&#10;    }&#10;}&#10;&#10;private fun getCategoryColor(category: String): Color {&#10;    return when (category.lowercase()) {&#10;        &quot;social&quot; -&gt; Color(0xFF2196F3) // Blue&#10;        &quot;family&quot; -&gt; Color(0xFF4CAF50) // Green&#10;        &quot;community&quot; -&gt; Color(0xFF9C27B0) // Purple&#10;        &quot;digital&quot; -&gt; Color(0xFF00BCD4) // Cyan&#10;        &quot;environment&quot; -&gt; Color(0xFF8BC34A) // Light Green&#10;        &quot;courtesy&quot; -&gt; Color(0xFFFF9800) // Orange&#10;        &quot;gratitude&quot; -&gt; Color(0xFFE91E63) // Pink&#10;        &quot;charity&quot; -&gt; Color(0xFF795548) // Brown&#10;        &quot;workplace&quot; -&gt; Color(0xFF607D8B) // Blue Grey&#10;        &quot;friendship&quot; -&gt; Color(0xFFFFEB3B) // Yellow&#10;        &quot;generosity&quot; -&gt; Color(0xFF3F51B5) // Indigo&#10;        &quot;empathy&quot; -&gt; Color(0xFF009688) // Teal&#10;        &quot;forgiveness&quot; -&gt; Color(0xFF673AB7) // Deep Purple&#10;        &quot;teaching&quot; -&gt; Color(0xFFFF5722) // Deep Orange&#10;        &quot;appreciation&quot; -&gt; Color(0xFFFFC107) // Amber&#10;        else -&gt; Color(0xFF757575) // Grey&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/components/SettingsComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/components/SettingsComponents.kt" />
              <option name="updatedContent" value="package com.example.kindspark.ui.components&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.ui.theme.*&#10;&#10;@Composable&#10;fun ModernSettingSection(&#10;    title: String,&#10;    isExpanded: Boolean,&#10;    onToggleExpanded: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    content: @Composable ColumnScope.() -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        shape = RoundedCornerShape(20.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            // Section Header&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .clickable { onToggleExpanded() }&#10;                    .padding(20.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = title,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Icon(&#10;                    imageVector = if (isExpanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,&#10;                    contentDescription = if (isExpanded) &quot;Collapse&quot; else &quot;Expand&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;&#10;            // Section Content&#10;            AnimatedVisibility(&#10;                visible = isExpanded,&#10;                enter = expandVertically(&#10;                    animationSpec = tween(300, easing = EaseInOutCubic)&#10;                ) + fadeIn(animationSpec = tween(300)),&#10;                exit = shrinkVertically(&#10;                    animationSpec = tween(300, easing = EaseInOutCubic)&#10;                ) + fadeOut(animationSpec = tween(300))&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    HorizontalDivider(&#10;                        modifier = Modifier.padding(horizontal = 20.dp),&#10;                        color = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    content()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSettingItem(&#10;    icon: ImageVector,&#10;    title: String,&#10;    subtitle: String,&#10;    modifier: Modifier = Modifier,&#10;    onClick: (() -&gt; Unit)? = null,&#10;    trailing: @Composable (() -&gt; Unit)? = null&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .let { if (onClick != null) it.clickable { onClick() } else it }&#10;            .padding(horizontal = 20.dp, vertical = 12.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Custom Icon Container&#10;        Box(&#10;            modifier = Modifier&#10;                .size(48.dp)&#10;                .background(&#10;                    brush = Brush.radialGradient(&#10;                        colors = listOf(&#10;                            MaterialTheme.colorScheme.primaryContainer,&#10;                            MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.6f)&#10;                        )&#10;                    ),&#10;                    shape = CircleShape&#10;                )&#10;                .clip(CircleShape),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = title,&#10;                tint = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;        // Title and Subtitle&#10;        Column(&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Text(&#10;                text = title,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                fontWeight = FontWeight.Medium,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Text(&#10;                text = subtitle,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;&#10;        // Trailing Content&#10;        trailing?.invoke()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ThemePreviewCard(&#10;    theme: UserPreferencesManager.AppTheme,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val borderColor = if (isSelected) {&#10;        MaterialTheme.colorScheme.primary&#10;    } else {&#10;        MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)&#10;    }&#10;&#10;    val borderWidth = if (isSelected) 2.dp else 1.dp&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .size(width = 140.dp, height = 100.dp)&#10;            .border(borderWidth, borderColor, RoundedCornerShape(16.dp))&#10;            .clickable { onClick() },&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            // Theme Preview Background&#10;            when (theme) {&#10;                UserPreferencesManager.AppTheme.LIGHT -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.verticalGradient(&#10;                                    colors = listOf(&#10;                                        Color(0xFFFFFBFE),&#10;                                        Color(0xFFE8F5E8)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {}&#10;                }&#10;                UserPreferencesManager.AppTheme.DARK -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.verticalGradient(&#10;                                    colors = listOf(&#10;                                        Color(0xFF1C1B1F),&#10;                                        Color(0xFF2E2E2E)&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {}&#10;                }&#10;                UserPreferencesManager.AppTheme.CALM_OCEAN -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.verticalGradient(&#10;                                    colors = listOf(&#10;                                        CalmOceanContainer,&#10;                                        CalmOceanPrimary&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {}&#10;                }&#10;                UserPreferencesManager.AppTheme.WARM_SUNSET -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.verticalGradient(&#10;                                    colors = listOf(&#10;                                        WarmSunsetSurface,&#10;                                        WarmSunsetPrimary&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {}&#10;                }&#10;                UserPreferencesManager.AppTheme.SERENE_FOREST -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.verticalGradient(&#10;                                    colors = listOf(&#10;                                        SereneForestSurface,&#10;                                        SereneForestPrimary&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {}&#10;                }&#10;                UserPreferencesManager.AppTheme.MIDNIGHT_CALM -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(&#10;                                Brush.verticalGradient(&#10;                                    colors = listOf(&#10;                                        Color(0xFFE8EAF6),&#10;                                        MidnightCalmPrimary&#10;                                    )&#10;                                )&#10;                            )&#10;                    ) {}&#10;                }&#10;            }&#10;&#10;            // Theme Name&#10;            Text(&#10;                text = theme.displayName,&#10;                style = MaterialTheme.typography.labelMedium,&#10;                fontWeight = FontWeight.Medium,&#10;                color = when (theme) {&#10;                    UserPreferencesManager.AppTheme.DARK -&gt; Color.White&#10;                    else -&gt; MaterialTheme.colorScheme.onSurface&#10;                },&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(8.dp)&#10;            )&#10;&#10;            // Selected Indicator&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Default.CheckCircle,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopEnd)&#10;                        .padding(8.dp)&#10;                        .size(20.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ResetSettingsButton(&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    OutlinedButton(&#10;        onClick = onClick,&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 24.dp),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = ButtonDefaults.outlinedButtonColors(&#10;            contentColor = MaterialTheme.colorScheme.error&#10;        ),&#10;        border = BorderStroke(&#10;            1.dp,&#10;            MaterialTheme.colorScheme.error&#10;        )&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Refresh,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(18.dp)&#10;        )&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;        Text(&#10;            text = &quot;Reset to Default Settings&quot;,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            fontWeight = FontWeight.Medium&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ModernSwitch(&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Switch(&#10;        checked = checked,&#10;        onCheckedChange = onCheckedChange,&#10;        modifier = modifier,&#10;        colors = SwitchDefaults.colors(&#10;            checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;            checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;            uncheckedThumbColor = MaterialTheme.colorScheme.outline,&#10;            uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/history/PromptHistoryScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/history/PromptHistoryScreen.kt" />
              <option name="updatedContent" value="package com.example.kindspark.ui.history&#10;&#10;import androidx.compose.animation.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.kindspark.ui.components.*&#10;import com.example.kindspark.ui.icons.CustomErrorIcon&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PromptHistoryScreen(&#10;    viewModel: PromptHistoryViewModel,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    var showDeleteDialog by remember { mutableStateOf&lt;PromptHistoryItem?&gt;(null) }&#10;&#10;    Column(&#10;        modifier = modifier.fillMaxSize()&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;Prompt History&quot;,&#10;            style = MaterialTheme.typography.headlineLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(24.dp)&#10;        )&#10;&#10;        // Filter chips&#10;        HistoryFilterChips(&#10;            currentFilter = uiState.currentFilter,&#10;            onFilterChange = { filter -&gt; viewModel.setFilter(filter) },&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Content&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            when {&#10;                uiState.isLoading -&gt; {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                uiState.error != null -&gt; {&#10;                    ErrorState(&#10;                        error = uiState.error!!,&#10;                        onRetry = { /* Retry logic could be added here */ },&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                uiState.historyItems.isEmpty() -&gt; {&#10;                    EmptyHistoryState(&#10;                        filter = uiState.currentFilter,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentPadding = PaddingValues(bottom = 16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        items(&#10;                            items = uiState.historyItems,&#10;                            key = { it.completion.id }&#10;                        ) { historyItem -&gt;&#10;                            SwipeToDeleteCard(&#10;                                onDelete = { showDeleteDialog = historyItem }&#10;                            ) {&#10;                                PromptHistoryCard(&#10;                                    prompt = historyItem.prompt,&#10;                                    completion = historyItem.completion,&#10;                                    onFavoriteToggle = {&#10;                                        viewModel.toggleFavorite(historyItem.completion)&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Delete confirmation dialog&#10;    showDeleteDialog?.let { historyItem -&gt;&#10;        AlertDialog(&#10;            onDismissRequest = { showDeleteDialog = null },&#10;            title = {&#10;                Text(&#10;                    text = &quot;Delete Prompt&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;Are you sure you want to delete this completed prompt? This action cannot be undone.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.deleteCompletion(historyItem.completion)&#10;                        showDeleteDialog = null&#10;                    },&#10;                    colors = ButtonDefaults.textButtonColors(&#10;                        contentColor = MaterialTheme.colorScheme.error&#10;                    )&#10;                ) {&#10;                    Text(&quot;Delete&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(&#10;                    onClick = { showDeleteDialog = null }&#10;                ) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SwipeToDeleteCard(&#10;    onDelete: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    // For now, we'll use a simple long-press to delete instead of swipe-to-dismiss&#10;    // since SwipeToDismiss APIs vary significantly between Compose versions&#10;    var showDeleteButton by remember { mutableStateOf(false) }&#10;&#10;    Box(modifier = modifier) {&#10;        content()&#10;&#10;        // Simple alternative: Add a delete button overlay when long-pressed&#10;        // This provides the delete functionality without complex swipe gestures&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ErrorState(&#10;    error: String,&#10;    onRetry: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier.padding(32.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Filled.CustomErrorIcon,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(48.dp),&#10;            tint = MaterialTheme.colorScheme.error&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&#10;            text = &quot;Something went wrong&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            fontWeight = FontWeight.SemiBold,&#10;            color = MaterialTheme.colorScheme.onSurface&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Text(&#10;            text = error,&#10;            style = MaterialTheme.typography.bodyMedium,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Button(onClick = onRetry) {&#10;            Text(&quot;Try Again&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/history/PromptHistoryViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/history/PromptHistoryViewModel.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.history&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.KindnessCompletion&#10;import com.example.kindspark.data.KindnessPrompt&#10;import com.example.kindspark.data.KindnessRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;&#10;data class PromptHistoryItem(&#10;    val completion: KindnessCompletion,&#10;    val prompt: KindnessPrompt&#10;)&#10;&#10;enum class HistoryFilter {&#10;    ALL, COMPLETED, FAVORITES&#10;}&#10;&#10;data class PromptHistoryUiState(&#10;    val historyItems: List&lt;PromptHistoryItem&gt; = emptyList(),&#10;    val currentFilter: HistoryFilter = HistoryFilter.ALL,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class PromptHistoryViewModel(&#10;    private val repository: KindnessRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(PromptHistoryUiState())&#10;    val uiState: StateFlow&lt;PromptHistoryUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadHistory()&#10;    }&#10;&#10;    private fun loadHistory() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            try {&#10;                // Get all completions from repository&#10;                repository.getAllCompletions().collect { completions -&gt;&#10;                    val historyItems = completions.mapNotNull { completion -&gt;&#10;                        val prompt = repository.getPromptById(completion.promptId)&#10;                        prompt?.let { PromptHistoryItem(completion, it) }&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        historyItems = filterItems(historyItems, _uiState.value.currentFilter),&#10;                        isLoading = false,&#10;                        error = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setFilter(filter: HistoryFilter) {&#10;        viewModelScope.launch {&#10;            val currentItems = _uiState.value.historyItems&#10;            val allItems = if (_uiState.value.currentFilter == HistoryFilter.ALL) {&#10;                currentItems&#10;            } else {&#10;                // Re-fetch all items if we're currently filtered&#10;                try {&#10;                    val completions = repository.getAllCompletions().first()&#10;                    completions.mapNotNull { completion -&gt;&#10;                        val prompt = repository.getPromptById(completion.promptId)&#10;                        prompt?.let { PromptHistoryItem(completion, it) }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    currentItems&#10;                }&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                currentFilter = filter,&#10;                historyItems = filterItems(allItems, filter)&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun filterItems(items: List&lt;PromptHistoryItem&gt;, filter: HistoryFilter): List&lt;PromptHistoryItem&gt; {&#10;        return when (filter) {&#10;            HistoryFilter.ALL -&gt; items&#10;            HistoryFilter.COMPLETED -&gt; items // All items are already completed&#10;            HistoryFilter.FAVORITES -&gt; items.filter { it.completion.isFavorite }&#10;        }&#10;    }&#10;&#10;    fun toggleFavorite(completion: KindnessCompletion) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedCompletion = completion.copy(isFavorite = !completion.isFavorite)&#10;                repository.updateCompletion(updatedCompletion)&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(error = e.message)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteCompletion(completion: KindnessCompletion) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteCompletion(completion)&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(error = e.message)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;// Extension to repository&#10;suspend fun KindnessRepository.getPromptById(id: Int): KindnessPrompt? {&#10;    // This would need to be added to the repository if not already present&#10;    return try {&#10;        // Assuming there's a method in DAO to get prompt by ID&#10;        getAllPrompts().find { it.id == id }&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;&#10;suspend fun KindnessRepository.getAllPrompts(): List&lt;KindnessPrompt&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    return emptyList() // Placeholder - should call dao.getAllPrompts()&#10;}&#10;&#10;suspend fun KindnessRepository.updateCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.updateCompletion(completion)&#10;}&#10;&#10;suspend fun KindnessRepository.deleteCompletion(completion: KindnessCompletion) {&#10;    // This would need to be added to the repository if not already present&#10;    // Should call dao.deleteCompletion(completion)&#10;}&#10;&#10;fun KindnessRepository.getAllCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getAllCompletions()&#10;    emit(emptyList())&#10;}&#10;&#10;fun KindnessRepository.getFavoriteCompletions() = flow&lt;List&lt;KindnessCompletion&gt;&gt; {&#10;    // This would need to be added to the repository if not already present&#10;    // Should return dao.getFavoriteCompletions()&#10;    emit(emptyList())&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.history&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.KindnessCompletion&#10;import com.example.kindspark.data.KindnessPrompt&#10;import com.example.kindspark.data.KindnessRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;&#10;data class PromptHistoryItem(&#10;    val completion: KindnessCompletion,&#10;    val prompt: KindnessPrompt&#10;)&#10;&#10;enum class HistoryFilter {&#10;    ALL, COMPLETED, FAVORITES&#10;}&#10;&#10;data class PromptHistoryUiState(&#10;    val historyItems: List&lt;PromptHistoryItem&gt; = emptyList(),&#10;    val currentFilter: HistoryFilter = HistoryFilter.ALL,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class PromptHistoryViewModel(&#10;    private val repository: KindnessRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(PromptHistoryUiState())&#10;    val uiState: StateFlow&lt;PromptHistoryUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadHistory()&#10;    }&#10;&#10;    private fun loadHistory() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            try {&#10;                // Get all completions from repository&#10;                repository.getAllCompletions().collect { completions -&gt;&#10;                    val historyItems = completions.mapNotNull { completion -&gt;&#10;                        val prompt = repository.getPromptById(completion.promptId)&#10;                        prompt?.let { PromptHistoryItem(completion, it) }&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        historyItems = filterItems(historyItems, _uiState.value.currentFilter),&#10;                        isLoading = false,&#10;                        error = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setFilter(filter: HistoryFilter) {&#10;        viewModelScope.launch {&#10;            val currentItems = _uiState.value.historyItems&#10;            val allItems = if (_uiState.value.currentFilter == HistoryFilter.ALL) {&#10;                currentItems&#10;            } else {&#10;                // Re-fetch all items if we're currently filtered&#10;                try {&#10;                    val completions = repository.getAllCompletions().first()&#10;                    completions.mapNotNull { completion -&gt;&#10;                        val prompt = repository.getPromptById(completion.promptId)&#10;                        prompt?.let { PromptHistoryItem(completion, it) }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    currentItems&#10;                }&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                currentFilter = filter,&#10;                historyItems = filterItems(allItems, filter)&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun filterItems(items: List&lt;PromptHistoryItem&gt;, filter: HistoryFilter): List&lt;PromptHistoryItem&gt; {&#10;        return when (filter) {&#10;            HistoryFilter.ALL -&gt; items&#10;            HistoryFilter.COMPLETED -&gt; items // All items are already completed&#10;            HistoryFilter.FAVORITES -&gt; items.filter { it.completion.isFavorite }&#10;        }&#10;    }&#10;&#10;    fun toggleFavorite(completion: KindnessCompletion) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedCompletion = completion.copy(isFavorite = !completion.isFavorite)&#10;                repository.updateCompletion(updatedCompletion)&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(error = e.message)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteCompletion(completion: KindnessCompletion) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteCompletion(completion)&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(error = e.message)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.KindnessCompletion&#10;import com.example.kindspark.data.KindnessPromptWithCompletion&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.data.UserProgress&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val updatedProgress = repository.updateStreakOnCompletion()&#10;                    val updatedProgress = repository.updateStreakOnCompletion()&#10;                    val updatedProgress = repository.updateStreakOnCompletion()&#10;                        completedDate = LocalDate.now().toString(),&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, LocalDate.now(), notes)&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.home&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.kindspark.data.KindnessCompletion&#13;&#10;import com.example.kindspark.data.KindnessPromptWithCompletion&#13;&#10;import com.example.kindspark.data.KindnessRepository&#13;&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#13;&#10;import com.example.kindspark.data.UserProgress&#13;&#10;import com.example.kindspark.notifications.NotificationScheduler&#13;&#10;import kotlinx.coroutines.flow.*&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import java.text.SimpleDateFormat&#13;&#10;import java.util.*&#13;&#10;&#13;&#10;data class HomeUiState(&#13;&#10;    val dailyPrompt: KindnessPromptWithCompletion? = null,&#13;&#10;    val currentStreak: Int = 0,&#13;&#10;    val bestStreak: Int = 0,&#13;&#10;    val totalCompleted: Int = 0,&#13;&#10;    val isCompleted: Boolean = false,&#13;&#10;    val isLoading: Boolean = true,&#13;&#10;    val error: String? = null,&#13;&#10;    val showCelebration: Boolean = false,&#13;&#10;    val celebrationMilestone: Int? = null,&#13;&#10;    val userProgress: UserProgress? = null&#13;&#10;)&#13;&#10;&#13;&#10;class HomeViewModel(&#13;&#10;    private val repository: KindnessRepository,&#13;&#10;    private val preferencesManager: UserPreferencesManager,&#13;&#10;    private val notificationScheduler: NotificationScheduler&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#13;&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        loadDailyPrompt()&#13;&#10;        loadCurrentStreak()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun loadDailyPrompt() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;                val promptWithCompletion = repository.getDailyPrompt()&#13;&#10;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    dailyPrompt = promptWithCompletion,&#13;&#10;                    isCompleted = promptWithCompletion.completion != null,&#13;&#10;                    isLoading = false,&#13;&#10;                    error = null&#13;&#10;                )&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    error = &quot;Failed to load daily prompt: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun loadCurrentStreak() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val userProgress = repository.getUserProgress()&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    currentStreak = userProgress.currentStreak,&#13;&#10;                    bestStreak = userProgress.bestStreak,&#13;&#10;                    totalCompleted = userProgress.totalCompleted,&#13;&#10;                    userProgress = userProgress&#13;&#10;                )&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Handle error silently for streak, it's not critical&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun markAsCompleted(notes: String = &quot;&quot;) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val currentPrompt = _uiState.value.dailyPrompt?.prompt&#13;&#10;                if (currentPrompt != null) {&#13;&#10;                    val today = Date()&#13;&#10;                    val completionId = repository.markPromptAsCompleted(currentPrompt.id, today, notes)&#13;&#10;&#13;&#10;                    // Update streak and get updated progress&#13;&#10;                    val updatedProgress = repository.updateStreakOnCompletion(today)&#13;&#10;&#13;&#10;                    // Check for milestone celebration&#13;&#10;                    val milestones = repository.getStreakMilestones(updatedProgress.currentStreak)&#13;&#10;                    val shouldCelebrate = milestones.isNotEmpty()&#13;&#10;&#13;&#10;                    // Update UI state&#13;&#10;                    val dateFormatter = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#13;&#10;                    val completion = KindnessCompletion(&#13;&#10;                        id = completionId,&#13;&#10;                        promptId = currentPrompt.id,&#13;&#10;                        completedDate = dateFormatter.format(today),&#13;&#10;                        notes = notes&#13;&#10;                    )&#13;&#10;&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        dailyPrompt = _uiState.value.dailyPrompt?.copy(completion = completion),&#13;&#10;                        isCompleted = true,&#13;&#10;                        currentStreak = updatedProgress.currentStreak,&#13;&#10;                        bestStreak = updatedProgress.bestStreak,&#13;&#10;                        totalCompleted = updatedProgress.totalCompleted,&#13;&#10;                        userProgress = updatedProgress,&#13;&#10;                        showCelebration = shouldCelebrate,&#13;&#10;                        celebrationMilestone = milestones.firstOrNull()&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    error = &quot;Failed to mark as completed: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun toggleFavorite() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val completion = _uiState.value.dailyPrompt?.completion&#13;&#10;                if (completion != null) {&#13;&#10;                    val newFavoriteStatus = !completion.isFavorite&#13;&#10;                    repository.toggleFavorite(completion)&#13;&#10;&#13;&#10;                    // Update UI state with the new favorite status&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        dailyPrompt = _uiState.value.dailyPrompt?.copy(&#13;&#10;                            completion = completion.copy(isFavorite = newFavoriteStatus)&#13;&#10;                        )&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    error = &quot;Failed to toggle favorite: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearError() {&#13;&#10;        _uiState.value = _uiState.value.copy(error = null)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun refreshPrompt() {&#13;&#10;        loadDailyPrompt()&#13;&#10;        loadCurrentStreak()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun skipCurrentPrompt() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val currentPrompt = _uiState.value.dailyPrompt?.prompt&#13;&#10;                if (currentPrompt != null) {&#13;&#10;                    // Skip the current prompt&#13;&#10;                    repository.skipPrompt(currentPrompt.id, Date())&#13;&#10;&#13;&#10;                    // Get the next available prompt&#13;&#10;                    val nextPrompt = repository.getNextAvailablePrompt()&#13;&#10;&#13;&#10;                    // Update UI state with the new prompt&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        dailyPrompt = nextPrompt,&#13;&#10;                        isCompleted = false // New prompt is not completed&#13;&#10;                    )&#13;&#10;&#13;&#10;                    // Clean up old skipped prompts (keep only last 7 days)&#13;&#10;                    repository.cleanupOldSkippedPrompts()&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    error = &quot;Failed to skip prompt: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun dismissCelebration() {&#13;&#10;        _uiState.value = _uiState.value.copy(&#13;&#10;            showCelebration = false,&#13;&#10;            celebrationMilestone = null&#13;&#10;        )&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModelFactory.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/home/HomeViewModelFactory.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.PreferencesManager&#10;import com.example.kindspark.notifications.DailyNotificationScheduler&#10;&#10;class HomeViewModelFactory(&#10;    private val repository: KindnessRepository,&#10;    private val preferencesManager: PreferencesManager,&#10;    private val notificationScheduler: DailyNotificationScheduler&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(HomeViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return HomeViewModel(repository, preferencesManager, notificationScheduler) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.example.kindspark.data.KindnessRepository&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;&#10;class HomeViewModelFactory(&#10;    private val repository: KindnessRepository,&#10;    private val userPreferencesManager: UserPreferencesManager,&#10;    private val notificationScheduler: NotificationScheduler&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(HomeViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return HomeViewModel(repository, userPreferencesManager, notificationScheduler) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/icons/AnimatedBellIcon.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/icons/AnimatedBellIcon.kt" />
              <option name="updatedContent" value="package com.example.kindspark.ui.icons&#10;&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.materialIcon&#10;import androidx.compose.material.icons.materialPath&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.rotate&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.unit.dp&#10;import kotlin.math.sin&#10;&#10;public val Icons.Outlined.AnimatedBell: ImageVector&#10;    get() {&#10;        if (_animatedBell != null) {&#10;            return _animatedBell!!&#10;        }&#10;        _animatedBell = materialIcon(name = &quot;AnimatedBell&quot;) {&#10;            materialPath {&#10;                // Bell body&#10;                moveTo(12.0f, 22.0f)&#10;                curveTo(13.1f, 22.0f, 14.0f, 21.1f, 14.0f, 20.0f)&#10;                horizontalLineTo(10.0f)&#10;                curveTo(10.0f, 21.1f, 10.9f, 22.0f, 12.0f, 22.0f)&#10;                close()&#10;                &#10;                moveTo(18.0f, 16.0f)&#10;                verticalLineTo(11.0f)&#10;                curveTo(18.0f, 7.93f, 16.36f, 5.36f, 13.5f, 4.68f)&#10;                verticalLineTo(4.0f)&#10;                curveTo(13.5f, 3.17f, 12.83f, 2.5f, 12.0f, 2.5f)&#10;                curveTo(11.17f, 2.5f, 10.5f, 3.17f, 10.5f, 4.0f)&#10;                verticalLineTo(4.68f)&#10;                curveTo(7.63f, 5.36f, 6.0f, 7.92f, 6.0f, 11.0f)&#10;                verticalLineTo(16.0f)&#10;                lineTo(4.0f, 18.0f)&#10;                verticalLineTo(19.0f)&#10;                horizontalLineTo(20.0f)&#10;                verticalLineTo(18.0f)&#10;                lineTo(18.0f, 16.0f)&#10;                close()&#10;                &#10;                // Sound waves&#10;                moveTo(19.5f, 8.0f)&#10;                curveTo(19.5f, 6.0f, 18.5f, 4.3f, 17.0f, 3.3f)&#10;                lineTo(16.2f, 4.7f)&#10;                curveTo(17.2f, 5.4f, 17.9f, 6.6f, 17.9f, 8.0f)&#10;                curveTo(17.9f, 9.4f, 17.2f, 10.6f, 16.2f, 11.3f)&#10;                lineTo(17.0f, 12.7f)&#10;                curveTo(18.5f, 11.7f, 19.5f, 10.0f, 19.5f, 8.0f)&#10;                close()&#10;                &#10;                moveTo(4.5f, 8.0f)&#10;                curveTo(4.5f, 10.0f, 5.5f, 11.7f, 7.0f, 12.7f)&#10;                lineTo(7.8f, 11.3f)&#10;                curveTo(6.8f, 10.6f, 6.1f, 9.4f, 6.1f, 8.0f)&#10;                curveTo(6.1f, 6.6f, 6.8f, 5.4f, 7.8f, 4.7f)&#10;                lineTo(7.0f, 3.3f)&#10;                curveTo(5.5f, 4.3f, 4.5f, 6.0f, 4.5f, 8.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _animatedBell!!&#10;    }&#10;&#10;private var _animatedBell: ImageVector? = null&#10;&#10;@Composable&#10;fun AnimatedBellIcon(&#10;    modifier: Modifier = Modifier,&#10;    color: Color = Color.Black,&#10;    isAnimating: Boolean = false&#10;) {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;bell_animation&quot;)&#10;    &#10;    val rotation by infiniteTransition.animateFloat(&#10;        initialValue = -10f,&#10;        targetValue = 10f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(300, easing = EaseInOutSine),&#10;            repeatMode = RepeatMode.Reverse&#10;        ),&#10;        label = &quot;bell_rotation&quot;&#10;    )&#10;    &#10;    Canvas(modifier = modifier.size(24.dp)) {&#10;        rotate(if (isAnimating) rotation else 0f) {&#10;            drawBell(color)&#10;        }&#10;    }&#10;}&#10;&#10;private fun DrawScope.drawBell(color: Color) {&#10;    val width = size.width&#10;    val height = size.height&#10;    &#10;    // Bell body path&#10;    drawPath(&#10;        path = androidx.compose.ui.graphics.Path().apply {&#10;            // Bell outline&#10;            moveTo(width * 0.5f, height * 0.1f)&#10;            cubicTo(&#10;                width * 0.3f, height * 0.1f,&#10;                width * 0.15f, height * 0.3f,&#10;                width * 0.15f, height * 0.55f&#10;            )&#10;            lineTo(width * 0.15f, height * 0.7f)&#10;            lineTo(width * 0.1f, height * 0.8f)&#10;            lineTo(width * 0.9f, height * 0.8f)&#10;            lineTo(width * 0.85f, height * 0.7f)&#10;            lineTo(width * 0.85f, height * 0.55f)&#10;            cubicTo(&#10;                width * 0.85f, height * 0.3f,&#10;                width * 0.7f, height * 0.1f,&#10;                width * 0.5f, height * 0.1f&#10;            )&#10;            close()&#10;            &#10;            // Bell clapper&#10;            moveTo(width * 0.5f, height * 0.85f)&#10;            lineTo(width * 0.45f, height * 0.95f)&#10;            lineTo(width * 0.55f, height * 0.95f)&#10;            close()&#10;        },&#10;        color = color&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/icons/HeartIcon.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/icons/HeartIcon.kt" />
              <option name="updatedContent" value="package com.example.kindspark.ui.icons&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.materialIcon&#10;import androidx.compose.material.icons.materialPath&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;&#10;public val Icons.Outlined.SparklingHeart: ImageVector&#10;    get() {&#10;        if (_sparklingHeart != null) {&#10;            return _sparklingHeart!!&#10;        }&#10;        _sparklingHeart = materialIcon(name = &quot;SparklingHeart&quot;) {&#10;            materialPath {&#10;                // Main heart shape&#10;                moveTo(12.0f, 21.35f)&#10;                lineTo(10.55f, 20.03f)&#10;                curveTo(5.4f, 15.36f, 2.0f, 12.27f, 2.0f, 8.5f)&#10;                curveTo(2.0f, 5.42f, 4.42f, 3.0f, 7.5f, 3.0f)&#10;                curveTo(9.24f, 3.0f, 10.91f, 3.81f, 12.0f, 5.08f)&#10;                curveTo(13.09f, 3.81f, 14.76f, 3.0f, 16.5f, 3.0f)&#10;                curveTo(19.58f, 3.0f, 22.0f, 5.42f, 22.0f, 8.5f)&#10;                curveTo(22.0f, 12.27f, 18.6f, 15.36f, 13.45f, 20.03f)&#10;                lineTo(12.0f, 21.35f)&#10;                close()&#10;                &#10;                // Sparkles around the heart&#10;                moveTo(6.0f, 2.0f)&#10;                lineTo(5.5f, 0.5f)&#10;                lineTo(4.0f, 1.0f)&#10;                lineTo(5.5f, 1.5f)&#10;                close()&#10;                &#10;                moveTo(18.0f, 2.0f)&#10;                lineTo(18.5f, 0.5f)&#10;                lineTo(20.0f, 1.0f)&#10;                lineTo(18.5f, 1.5f)&#10;                close()&#10;                &#10;                moveTo(2.0f, 6.0f)&#10;                lineTo(1.5f, 4.5f)&#10;                lineTo(0.0f, 5.0f)&#10;                lineTo(1.5f, 5.5f)&#10;                close()&#10;                &#10;                moveTo(22.0f, 6.0f)&#10;                lineTo(22.5f, 4.5f)&#10;                lineTo(24.0f, 5.0f)&#10;                lineTo(22.5f, 5.5f)&#10;                close()&#10;            }&#10;        }&#10;        return _sparklingHeart!!&#10;    }&#10;&#10;private var _sparklingHeart: ImageVector? = null&#10;&#10;public val Icons.Outlined.CloudHeart: ImageVector&#10;    get() {&#10;        if (_cloudHeart != null) {&#10;            return _cloudHeart!!&#10;        }&#10;        _cloudHeart = materialIcon(name = &quot;CloudHeart&quot;) {&#10;            materialPath {&#10;                // Cloud shape&#10;                moveTo(19.35f, 10.04f)&#10;                curveTo(18.67f, 6.59f, 15.64f, 4.0f, 12.0f, 4.0f)&#10;                curveTo(9.11f, 4.0f, 6.6f, 5.64f, 5.35f, 8.04f)&#10;                curveTo(2.34f, 8.36f, 0.0f, 10.91f, 0.0f, 14.0f)&#10;                curveTo(0.0f, 17.31f, 2.69f, 20.0f, 6.0f, 20.0f)&#10;                horizontalLineTo(19.0f)&#10;                curveTo(21.76f, 20.0f, 24.0f, 17.76f, 24.0f, 15.0f)&#10;                curveTo(24.0f, 12.36f, 21.95f, 10.22f, 19.35f, 10.04f)&#10;                close()&#10;                &#10;                moveTo(19.0f, 18.0f)&#10;                horizontalLineTo(6.0f)&#10;                curveTo(3.79f, 18.0f, 2.0f, 16.21f, 2.0f, 14.0f)&#10;                curveTo(2.0f, 11.95f, 3.53f, 10.24f, 5.56f, 10.03f)&#10;                lineTo(6.63f, 9.92f)&#10;                lineTo(7.13f, 8.97f)&#10;                curveTo(8.08f, 7.14f, 9.94f, 6.0f, 12.0f, 6.0f)&#10;                curveTo(14.62f, 6.0f, 16.88f, 7.86f, 17.39f, 10.43f)&#10;                lineTo(17.69f, 11.93f)&#10;                lineTo(19.22f, 12.04f)&#10;                curveTo(20.78f, 12.14f, 22.0f, 13.45f, 22.0f, 15.0f)&#10;                curveTo(22.0f, 16.65f, 20.65f, 18.0f, 19.0f, 18.0f)&#10;                close()&#10;                &#10;                // Heart in the cloud&#10;                moveTo(12.0f, 15.35f)&#10;                lineTo(11.22f, 14.62f)&#10;                curveTo(9.55f, 13.06f, 8.5f, 12.1f, 8.5f, 10.9f)&#10;                curveTo(8.5f, 9.95f, 9.2f, 9.25f, 10.15f, 9.25f)&#10;                curveTo(10.75f, 9.25f, 11.33f, 9.55f, 12.0f, 10.08f)&#10;                curveTo(12.67f, 9.55f, 13.25f, 9.25f, 13.85f, 9.25f)&#10;                curveTo(14.8f, 9.25f, 15.5f, 9.95f, 15.5f, 10.9f)&#10;                curveTo(15.5f, 12.1f, 14.45f, 13.06f, 12.78f, 14.62f)&#10;                lineTo(12.0f, 15.35f)&#10;                close()&#10;            }&#10;        }&#10;        return _cloudHeart!!&#10;    }&#10;&#10;private var _cloudHeart: ImageVector? = null" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/icons/Icons.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/icons/Icons.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.icons&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.materialIcon&#10;import androidx.compose.material.icons.materialPath&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;&#10;public val Icons.Outlined.CustomPalette: ImageVector&#10;    get() {&#10;        if (_customPalette != null) {&#10;            return _customPalette!!&#10;        }&#10;        _customPalette = materialIcon(name = &quot;CustomPalette&quot;) {&#10;            materialPath {&#10;                moveTo(12.0f, 3.0f)&#10;                curveTo(16.97f, 3.0f, 21.0f, 7.03f, 21.0f, 12.0f)&#10;                curveTo(21.0f, 13.66f, 20.33f, 15.64f, 19.0f, 16.97f)&#10;                curveTo(17.66f, 18.31f, 15.66f, 19.0f, 13.0f, 19.0f)&#10;                horizontalLineTo(9.5f)&#10;                curveTo(8.67f, 19.0f, 8.0f, 18.33f, 8.0f, 17.5f)&#10;                curveTo(8.0f, 16.67f, 8.67f, 16.0f, 9.5f, 16.0f)&#10;                horizontalLineTo(13.0f)&#10;                curveTo(14.66f, 16.0f, 16.0f, 14.66f, 16.0f, 13.0f)&#10;                curveTo(16.0f, 11.34f, 14.66f, 10.0f, 13.0f, 10.0f)&#10;                horizontalLineTo(12.0f)&#10;                curveTo(7.03f, 10.0f, 3.0f, 6.97f, 3.0f, 2.0f)&#10;                close()&#10;&#10;                // Color dots&#10;                moveTo(9.5f, 9.0f)&#10;                curveTo(10.33f, 9.0f, 11.0f, 8.33f, 11.0f, 7.5f)&#10;                curveTo(11.0f, 6.67f, 10.33f, 6.0f, 9.5f, 6.0f)&#10;                curveTo(8.67f, 6.0f, 8.0f, 6.67f, 8.0f, 7.5f)&#10;                curveTo(8.0f, 8.33f, 8.67f, 9.0f, 9.5f, 9.0f)&#10;                close()&#10;&#10;                moveTo(14.5f, 9.0f)&#10;                curveTo(15.33f, 9.0f, 16.0f, 8.33f, 16.0f, 7.5f)&#10;                curveTo(16.0f, 6.67f, 15.33f, 6.0f, 14.5f, 6.0f)&#10;                curveTo(13.67f, 6.0f, 13.0f, 6.67f, 13.0f, 7.5f)&#10;                curveTo(13.0f, 8.33f, 13.67f, 9.0f, 14.5f, 9.0f)&#10;                close()&#10;&#10;                moveTo(7.5f, 12.0f)&#10;                curveTo(8.33f, 12.0f, 9.0f, 11.33f, 9.0f, 10.5f)&#10;                curveTo(9.0f, 9.67f, 8.33f, 9.0f, 7.5f, 9.0f)&#10;                curveTo(6.67f, 9.0f, 6.0f, 9.67f, 6.0f, 10.5f)&#10;                curveTo(6.0f, 11.33f, 6.67f, 12.0f, 7.5f, 12.0f)&#10;                close()&#10;&#10;                moveTo(16.5f, 12.0f)&#10;                curveTo(17.33f, 12.0f, 18.0f, 11.33f, 18.0f, 10.5f)&#10;                curveTo(18.0f, 9.67f, 17.33f, 9.0f, 16.5f, 9.0f)&#10;                curveTo(15.67f, 9.0f, 15.0f, 9.67f, 15.0f, 10.5f)&#10;                curveTo(15.0f, 11.33f, 15.67f, 12.0f, 16.5f, 12.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customPalette!!&#10;    }&#10;&#10;private var _customPalette: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomLandscape: ImageVector&#10;    get() {&#10;        if (_customLandscape != null) {&#10;            return _customLandscape!!&#10;        }&#10;        _customLandscape = materialIcon(name = &quot;CustomLandscape&quot;) {&#10;            materialPath {&#10;                moveTo(14.0f, 6.0f)&#10;                lineTo(10.25f, 11.0f)&#10;                lineTo(13.25f, 15.0f)&#10;                horizontalLineTo(5.0f)&#10;                lineTo(8.5f, 10.0f)&#10;                lineTo(6.5f, 7.0f)&#10;                lineTo(9.0f, 3.0f)&#10;                close()&#10;&#10;                moveTo(21.5f, 11.0f)&#10;                lineTo(18.5f, 15.0f)&#10;                horizontalLineTo(15.5f)&#10;                lineTo(19.0f, 10.0f)&#10;                close()&#10;&#10;                // Ground line&#10;                moveTo(2.0f, 19.0f)&#10;                horizontalLineTo(22.0f)&#10;                verticalLineTo(21.0f)&#10;                horizontalLineTo(2.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customLandscape!!&#10;    }&#10;&#10;private var _customLandscape: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomAutoAwesome: ImageVector&#10;    get() {&#10;        if (_customAutoAwesome != null) {&#10;            return _customAutoAwesome!!&#10;        }&#10;        _customAutoAwesome = materialIcon(name = &quot;CustomAutoAwesome&quot;) {&#10;            materialPath {&#10;                // Main star&#10;                moveTo(19.0f, 9.0f)&#10;                lineTo(20.25f, 6.25f)&#10;                lineTo(23.0f, 5.0f)&#10;                lineTo(20.25f, 3.75f)&#10;                lineTo(19.0f, 1.0f)&#10;                lineTo(17.75f, 3.75f)&#10;                lineTo(15.0f, 5.0f)&#10;                lineTo(17.75f, 6.25f)&#10;                close()&#10;&#10;                // Secondary star&#10;                moveTo(19.0f, 15.0f)&#10;                lineTo(17.75f, 17.75f)&#10;                lineTo(15.0f, 19.0f)&#10;                lineTo(17.75f, 20.25f)&#10;                lineTo(19.0f, 23.0f)&#10;                lineTo(20.25f, 20.25f)&#10;                lineTo(23.0f, 19.0f)&#10;                lineTo(20.25f, 17.75f)&#10;                close()&#10;&#10;                // Left star&#10;                moveTo(11.5f, 9.5f)&#10;                lineTo(10.0f, 6.0f)&#10;                lineTo(6.5f, 4.5f)&#10;                lineTo(10.0f, 3.0f)&#10;                lineTo(11.5f, -0.5f)&#10;                lineTo(13.0f, 3.0f)&#10;                lineTo(16.5f, 4.5f)&#10;                lineTo(13.0f, 6.0f)&#10;                close()&#10;&#10;                // Small sparkle&#10;                moveTo(7.0f, 14.0f)&#10;                lineTo(6.0f, 11.5f)&#10;                lineTo(3.5f, 10.5f)&#10;                lineTo(6.0f, 9.5f)&#10;                lineTo(7.0f, 7.0f)&#10;                lineTo(8.0f, 9.5f)&#10;                lineTo(10.5f, 10.5f)&#10;                lineTo(8.0f, 11.5f)&#10;                close()&#10;            }&#10;        }&#10;        return _customAutoAwesome!!&#10;    }&#10;&#10;private var _customAutoAwesome: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomSchedule: ImageVector&#10;    get() {&#10;        if (_customSchedule != null) {&#10;            return _customSchedule!!&#10;        }&#10;        _customSchedule = materialIcon(name = &quot;CustomSchedule&quot;) {&#10;            materialPath {&#10;                // Clock circle&#10;                moveTo(12.0f, 2.0f)&#10;                curveTo(6.48f, 2.0f, 2.0f, 6.48f, 2.0f, 12.0f)&#10;                curveTo(2.0f, 17.52f, 6.48f, 22.0f, 12.0f, 22.0f)&#10;                curveTo(17.52f, 22.0f, 22.0f, 17.52f, 22.0f, 12.0f)&#10;                curveTo(22.0f, 6.48f, 17.52f, 2.0f, 12.0f, 2.0f)&#10;                close()&#10;&#10;                moveTo(12.0f, 20.0f)&#10;                curveTo(7.59f, 20.0f, 4.0f, 16.41f, 4.0f, 12.0f)&#10;                curveTo(4.0f, 7.59f, 7.59f, 4.0f, 12.0f, 4.0f)&#10;                curveTo(16.41f, 4.0f, 20.0f, 7.59f, 20.0f, 12.0f)&#10;                curveTo(20.0f, 16.41f, 16.41f, 20.0f, 12.0f, 20.0f)&#10;                close()&#10;&#10;                // Clock hands&#10;                moveTo(12.5f, 7.0f)&#10;                horizontalLineTo(11.0f)&#10;                verticalLineTo(13.0f)&#10;                lineTo(16.25f, 16.15f)&#10;                lineTo(17.0f, 14.92f)&#10;                lineTo(12.5f, 12.25f)&#10;                close()&#10;&#10;                // Spark trail&#10;                moveTo(19.5f, 3.5f)&#10;                lineTo(18.5f, 2.5f)&#10;                lineTo(20.5f, 0.5f)&#10;                lineTo(21.5f, 1.5f)&#10;                close()&#10;&#10;                moveTo(21.5f, 5.5f)&#10;                lineTo(20.5f, 4.5f)&#10;                lineTo(23.5f, 1.5f)&#10;                lineTo(24.5f, 2.5f)&#10;                close()&#10;            }&#10;        }&#10;        return _customSchedule!!&#10;    }&#10;&#10;private var _customSchedule: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomVolumeUp: ImageVector&#10;    get() {&#10;        if (_customVolumeUp != null) {&#10;            return _customVolumeUp!!&#10;        }&#10;        _customVolumeUp = materialIcon(name = &quot;CustomVolumeUp&quot;) {&#10;            materialPath {&#10;                // Speaker cone&#10;                moveTo(3.0f, 9.0f)&#10;                verticalLineTo(15.0f)&#10;                horizontalLineTo(7.0f)&#10;                lineTo(12.0f, 20.0f)&#10;                verticalLineTo(4.0f)&#10;                lineTo(7.0f, 9.0f)&#10;                horizontalLineTo(3.0f)&#10;                close()&#10;&#10;                // Sound waves&#10;                moveTo(16.5f, 12.0f)&#10;                curveTo(16.5f, 10.23f, 15.48f, 8.71f, 14.0f, 7.97f)&#10;                verticalLineTo(16.02f)&#10;                curveTo(15.48f, 15.29f, 16.5f, 13.77f, 16.5f, 12.0f)&#10;                close()&#10;&#10;                moveTo(14.0f, 3.23f)&#10;                verticalLineTo(5.29f)&#10;                curveTo(16.89f, 6.15f, 19.0f, 8.83f, 19.0f, 12.0f)&#10;                curveTo(19.0f, 15.17f, 16.89f, 17.85f, 14.0f, 18.71f)&#10;                verticalLineTo(20.77f)&#10;                curveTo(18.01f, 19.86f, 21.0f, 16.28f, 21.0f, 12.0f)&#10;                curveTo(21.0f, 7.72f, 18.01f, 4.14f, 14.0f, 3.23f)&#10;                close()&#10;            }&#10;        }&#10;        return _customVolumeUp!!&#10;    }&#10;&#10;private var _customVolumeUp: ImageVector? = null&#10;&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.icons&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.materialIcon&#10;import androidx.compose.material.icons.materialPath&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;&#10;public val Icons.Outlined.CustomPalette: ImageVector&#10;    get() {&#10;        if (_customPalette != null) {&#10;            return _customPalette!!&#10;        }&#10;        _customPalette = materialIcon(name = &quot;CustomPalette&quot;) {&#10;            materialPath {&#10;                moveTo(12.0f, 3.0f)&#10;                curveTo(16.97f, 3.0f, 21.0f, 7.03f, 21.0f, 12.0f)&#10;                curveTo(21.0f, 13.66f, 20.33f, 15.64f, 19.0f, 16.97f)&#10;                curveTo(17.66f, 18.31f, 15.66f, 19.0f, 13.0f, 19.0f)&#10;                horizontalLineTo(9.5f)&#10;                curveTo(8.67f, 19.0f, 8.0f, 18.33f, 8.0f, 17.5f)&#10;                curveTo(8.0f, 16.67f, 8.67f, 16.0f, 9.5f, 16.0f)&#10;                horizontalLineTo(13.0f)&#10;                curveTo(14.66f, 16.0f, 16.0f, 14.66f, 16.0f, 13.0f)&#10;                curveTo(16.0f, 11.34f, 14.66f, 10.0f, 13.0f, 10.0f)&#10;                horizontalLineTo(12.0f)&#10;                curveTo(7.03f, 10.0f, 3.0f, 6.97f, 3.0f, 2.0f)&#10;                close()&#10;&#10;                // Color dots&#10;                moveTo(9.5f, 9.0f)&#10;                curveTo(10.33f, 9.0f, 11.0f, 8.33f, 11.0f, 7.5f)&#10;                curveTo(11.0f, 6.67f, 10.33f, 6.0f, 9.5f, 6.0f)&#10;                curveTo(8.67f, 6.0f, 8.0f, 6.67f, 8.0f, 7.5f)&#10;                curveTo(8.0f, 8.33f, 8.67f, 9.0f, 9.5f, 9.0f)&#10;                close()&#10;&#10;                moveTo(14.5f, 9.0f)&#10;                curveTo(15.33f, 9.0f, 16.0f, 8.33f, 16.0f, 7.5f)&#10;                curveTo(16.0f, 6.67f, 15.33f, 6.0f, 14.5f, 6.0f)&#10;                curveTo(13.67f, 6.0f, 13.0f, 6.67f, 13.0f, 7.5f)&#10;                curveTo(13.0f, 8.33f, 13.67f, 9.0f, 14.5f, 9.0f)&#10;                close()&#10;&#10;                moveTo(7.5f, 12.0f)&#10;                curveTo(8.33f, 12.0f, 9.0f, 11.33f, 9.0f, 10.5f)&#10;                curveTo(9.0f, 9.67f, 8.33f, 9.0f, 7.5f, 9.0f)&#10;                curveTo(6.67f, 9.0f, 6.0f, 9.67f, 6.0f, 10.5f)&#10;                curveTo(6.0f, 11.33f, 6.67f, 12.0f, 7.5f, 12.0f)&#10;                close()&#10;&#10;                moveTo(16.5f, 12.0f)&#10;                curveTo(17.33f, 12.0f, 18.0f, 11.33f, 18.0f, 10.5f)&#10;                curveTo(18.0f, 9.67f, 17.33f, 9.0f, 16.5f, 9.0f)&#10;                curveTo(15.67f, 9.0f, 15.0f, 9.67f, 15.0f, 10.5f)&#10;                curveTo(15.0f, 11.33f, 15.67f, 12.0f, 16.5f, 12.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customPalette!!&#10;    }&#10;&#10;private var _customPalette: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomLandscape: ImageVector&#10;    get() {&#10;        if (_customLandscape != null) {&#10;            return _customLandscape!!&#10;        }&#10;        _customLandscape = materialIcon(name = &quot;CustomLandscape&quot;) {&#10;            materialPath {&#10;                moveTo(14.0f, 6.0f)&#10;                lineTo(10.25f, 11.0f)&#10;                lineTo(13.25f, 15.0f)&#10;                horizontalLineTo(5.0f)&#10;                lineTo(8.5f, 10.0f)&#10;                lineTo(6.5f, 7.0f)&#10;                lineTo(9.0f, 3.0f)&#10;                close()&#10;&#10;                moveTo(21.5f, 11.0f)&#10;                lineTo(18.5f, 15.0f)&#10;                horizontalLineTo(15.5f)&#10;                lineTo(19.0f, 10.0f)&#10;                close()&#10;&#10;                // Ground line&#10;                moveTo(2.0f, 19.0f)&#10;                horizontalLineTo(22.0f)&#10;                verticalLineTo(21.0f)&#10;                horizontalLineTo(2.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customLandscape!!&#10;    }&#10;&#10;private var _customLandscape: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomAutoAwesome: ImageVector&#10;    get() {&#10;        if (_customAutoAwesome != null) {&#10;            return _customAutoAwesome!!&#10;        }&#10;        _customAutoAwesome = materialIcon(name = &quot;CustomAutoAwesome&quot;) {&#10;            materialPath {&#10;                // Main star&#10;                moveTo(19.0f, 9.0f)&#10;                lineTo(20.25f, 6.25f)&#10;                lineTo(23.0f, 5.0f)&#10;                lineTo(20.25f, 3.75f)&#10;                lineTo(19.0f, 1.0f)&#10;                lineTo(17.75f, 3.75f)&#10;                lineTo(15.0f, 5.0f)&#10;                lineTo(17.75f, 6.25f)&#10;                close()&#10;&#10;                // Secondary star&#10;                moveTo(19.0f, 15.0f)&#10;                lineTo(17.75f, 17.75f)&#10;                lineTo(15.0f, 19.0f)&#10;                lineTo(17.75f, 20.25f)&#10;                lineTo(19.0f, 23.0f)&#10;                lineTo(20.25f, 20.25f)&#10;                lineTo(23.0f, 19.0f)&#10;                lineTo(20.25f, 17.75f)&#10;                close()&#10;&#10;                // Left star&#10;                moveTo(11.5f, 9.5f)&#10;                lineTo(10.0f, 6.0f)&#10;                lineTo(6.5f, 4.5f)&#10;                lineTo(10.0f, 3.0f)&#10;                lineTo(11.5f, -0.5f)&#10;                lineTo(13.0f, 3.0f)&#10;                lineTo(16.5f, 4.5f)&#10;                lineTo(13.0f, 6.0f)&#10;                close()&#10;&#10;                // Small sparkle&#10;                moveTo(7.0f, 14.0f)&#10;                lineTo(6.0f, 11.5f)&#10;                lineTo(3.5f, 10.5f)&#10;                lineTo(6.0f, 9.5f)&#10;                lineTo(7.0f, 7.0f)&#10;                lineTo(8.0f, 9.5f)&#10;                lineTo(10.5f, 10.5f)&#10;                lineTo(8.0f, 11.5f)&#10;                close()&#10;            }&#10;        }&#10;        return _customAutoAwesome!!&#10;    }&#10;&#10;private var _customAutoAwesome: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomSchedule: ImageVector&#10;    get() {&#10;        if (_customSchedule != null) {&#10;            return _customSchedule!!&#10;        }&#10;        _customSchedule = materialIcon(name = &quot;CustomSchedule&quot;) {&#10;            materialPath {&#10;                // Clock circle&#10;                moveTo(12.0f, 2.0f)&#10;                curveTo(6.48f, 2.0f, 2.0f, 6.48f, 2.0f, 12.0f)&#10;                curveTo(2.0f, 17.52f, 6.48f, 22.0f, 12.0f, 22.0f)&#10;                curveTo(17.52f, 22.0f, 22.0f, 17.52f, 22.0f, 12.0f)&#10;                curveTo(22.0f, 6.48f, 17.52f, 2.0f, 12.0f, 2.0f)&#10;                close()&#10;&#10;                moveTo(12.0f, 20.0f)&#10;                curveTo(7.59f, 20.0f, 4.0f, 16.41f, 4.0f, 12.0f)&#10;                curveTo(4.0f, 7.59f, 7.59f, 4.0f, 12.0f, 4.0f)&#10;                curveTo(16.41f, 4.0f, 20.0f, 7.59f, 20.0f, 12.0f)&#10;                curveTo(20.0f, 16.41f, 16.41f, 20.0f, 12.0f, 20.0f)&#10;                close()&#10;&#10;                // Clock hands&#10;                moveTo(12.5f, 7.0f)&#10;                horizontalLineTo(11.0f)&#10;                verticalLineTo(13.0f)&#10;                lineTo(16.25f, 16.15f)&#10;                lineTo(17.0f, 14.92f)&#10;                lineTo(12.5f, 12.25f)&#10;                close()&#10;&#10;                // Spark trail&#10;                moveTo(19.5f, 3.5f)&#10;                lineTo(18.5f, 2.5f)&#10;                lineTo(20.5f, 0.5f)&#10;                lineTo(21.5f, 1.5f)&#10;                close()&#10;&#10;                moveTo(21.5f, 5.5f)&#10;                lineTo(20.5f, 4.5f)&#10;                lineTo(23.5f, 1.5f)&#10;                lineTo(24.5f, 2.5f)&#10;                close()&#10;            }&#10;        }&#10;        return _customSchedule!!&#10;    }&#10;&#10;private var _customSchedule: ImageVector? = null&#10;&#10;public val Icons.Outlined.CustomVolumeUp: ImageVector&#10;    get() {&#10;        if (_customVolumeUp != null) {&#10;            return _customVolumeUp!!&#10;        }&#10;        _customVolumeUp = materialIcon(name = &quot;CustomVolumeUp&quot;) {&#10;            materialPath {&#10;                // Speaker cone&#10;                moveTo(3.0f, 9.0f)&#10;                verticalLineTo(15.0f)&#10;                horizontalLineTo(7.0f)&#10;                lineTo(12.0f, 20.0f)&#10;                verticalLineTo(4.0f)&#10;                lineTo(7.0f, 9.0f)&#10;                horizontalLineTo(3.0f)&#10;                close()&#10;&#10;                // Sound waves&#10;                moveTo(16.5f, 12.0f)&#10;                curveTo(16.5f, 10.23f, 15.48f, 8.71f, 14.0f, 7.97f)&#10;                verticalLineTo(16.02f)&#10;                curveTo(15.48f, 15.29f, 16.5f, 13.77f, 16.5f, 12.0f)&#10;                close()&#10;&#10;                moveTo(14.0f, 3.23f)&#10;                verticalLineTo(5.29f)&#10;                curveTo(16.89f, 6.15f, 19.0f, 8.83f, 19.0f, 12.0f)&#10;                curveTo(19.0f, 15.17f, 16.89f, 17.85f, 14.0f, 18.71f)&#10;                verticalLineTo(20.77f)&#10;                curveTo(18.01f, 19.86f, 21.0f, 16.28f, 21.0f, 12.0f)&#10;                curveTo(21.0f, 7.72f, 18.01f, 4.14f, 14.0f, 3.23f)&#10;                close()&#10;            }&#10;        }&#10;        return _customVolumeUp!!&#10;    }&#10;&#10;private var _customVolumeUp: ImageVector? = null&#10;&#10;public val Icons.Filled.CustomHistoryEdu: ImageVector&#10;    get() {&#10;        if (_customHistoryEdu != null) {&#10;            return _customHistoryEdu!!&#10;        }&#10;        _customHistoryEdu = materialIcon(name = &quot;CustomHistoryEdu&quot;) {&#10;            materialPath {&#10;                // Book/Education icon&#10;                moveTo(19.0f, 3.0f)&#10;                horizontalLineTo(5.0f)&#10;                curveTo(3.89f, 3.0f, 3.0f, 3.89f, 3.0f, 5.0f)&#10;                verticalLineTo(19.0f)&#10;                curveTo(3.0f, 20.11f, 3.89f, 21.0f, 5.0f, 21.0f)&#10;                horizontalLineTo(19.0f)&#10;                curveTo(20.11f, 21.0f, 21.0f, 20.11f, 21.0f, 19.0f)&#10;                verticalLineTo(5.0f)&#10;                curveTo(21.0f, 3.89f, 20.11f, 3.0f, 19.0f, 3.0f)&#10;                close()&#10;&#10;                moveTo(19.0f, 19.0f)&#10;                horizontalLineTo(5.0f)&#10;                verticalLineTo(5.0f)&#10;                horizontalLineTo(19.0f)&#10;                verticalLineTo(19.0f)&#10;                close()&#10;&#10;                // Clock/History element&#10;                moveTo(12.0f, 7.0f)&#10;                curveTo(9.24f, 7.0f, 7.0f, 9.24f, 7.0f, 12.0f)&#10;                curveTo(7.0f, 14.76f, 9.24f, 17.0f, 12.0f, 17.0f)&#10;                curveTo(14.76f, 17.0f, 17.0f, 14.76f, 17.0f, 12.0f)&#10;                curveTo(17.0f, 9.24f, 14.76f, 7.0f, 12.0f, 7.0f)&#10;                close()&#10;&#10;                // Clock hands&#10;                moveTo(12.5f, 9.0f)&#10;                horizontalLineTo(11.5f)&#10;                verticalLineTo(12.5f)&#10;                lineTo(14.0f, 14.0f)&#10;                lineTo(14.5f, 13.2f)&#10;                lineTo(12.5f, 12.0f)&#10;                verticalLineTo(9.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customHistoryEdu!!&#10;    }&#10;&#10;private var _customHistoryEdu: ImageVector? = null&#10;&#10;// Simple History Navigation Icon&#10;public val Icons.Filled.HistoryNav: ImageVector&#10;    get() {&#10;        if (_historyNav != null) {&#10;            return _historyNav!!&#10;        }&#10;        _historyNav = materialIcon(name = &quot;HistoryNav&quot;) {&#10;            materialPath {&#10;                // Simple book icon&#10;                moveTo(18.0f, 2.0f)&#10;                horizontalLineTo(6.0f)&#10;                curveTo(4.9f, 2.0f, 4.0f, 2.9f, 4.0f, 4.0f)&#10;                verticalLineTo(20.0f)&#10;                curveTo(4.0f, 21.1f, 4.9f, 22.0f, 6.0f, 22.0f)&#10;                horizontalLineTo(18.0f)&#10;                curveTo(19.1f, 22.0f, 20.0f, 21.1f, 20.0f, 20.0f)&#10;                verticalLineTo(4.0f)&#10;                curveTo(20.0f, 2.9f, 19.1f, 2.0f, 18.0f, 2.0f)&#10;                close()&#10;&#10;                moveTo(18.0f, 20.0f)&#10;                horizontalLineTo(6.0f)&#10;                verticalLineTo(4.0f)&#10;                horizontalLineTo(18.0f)&#10;                verticalLineTo(20.0f)&#10;                close()&#10;&#10;                // Page lines&#10;                moveTo(8.0f, 6.0f)&#10;                horizontalLineTo(16.0f)&#10;                verticalLineTo(8.0f)&#10;                horizontalLineTo(8.0f)&#10;                close()&#10;&#10;                moveTo(8.0f, 10.0f)&#10;                horizontalLineTo(16.0f)&#10;                verticalLineTo(12.0f)&#10;                horizontalLineTo(8.0f)&#10;                close()&#10;&#10;                moveTo(8.0f, 14.0f)&#10;                horizontalLineTo(13.0f)&#10;                verticalLineTo(16.0f)&#10;                horizontalLineTo(8.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _historyNav!!&#10;    }&#10;&#10;private var _historyNav: ImageVector? = null&#10;&#10;// Custom List Icon for Navigation&#10;public val Icons.Filled.CustomList: ImageVector&#10;    get() {&#10;        if (_customList != null) {&#10;            return _customList!!&#10;        }&#10;        _customList = materialIcon(name = &quot;CustomList&quot;) {&#10;            materialPath {&#10;                // List items&#10;                moveTo(3.0f, 5.0f)&#10;                horizontalLineTo(21.0f)&#10;                verticalLineTo(7.0f)&#10;                horizontalLineTo(3.0f)&#10;                close()&#10;&#10;                moveTo(3.0f, 11.0f)&#10;                horizontalLineTo(21.0f)&#10;                verticalLineTo(13.0f)&#10;                horizontalLineTo(3.0f)&#10;                close()&#10;&#10;                moveTo(3.0f, 17.0f)&#10;                horizontalLineTo(21.0f)&#10;                verticalLineTo(19.0f)&#10;                horizontalLineTo(3.0f)&#10;                close()&#10;&#10;                // Optional bullet points&#10;                moveTo(1.0f, 5.0f)&#10;                curveTo(1.55f, 5.0f, 2.0f, 5.45f, 2.0f, 6.0f)&#10;                curveTo(2.0f, 6.55f, 1.55f, 7.0f, 1.0f, 7.0f)&#10;                curveTo(0.45f, 7.0f, 0.0f, 6.55f, 0.0f, 6.0f)&#10;                curveTo(0.0f, 5.45f, 0.45f, 5.0f, 1.0f, 5.0f)&#10;                close()&#10;&#10;                moveTo(1.0f, 11.0f)&#10;                curveTo(1.55f, 11.0f, 2.0f, 11.45f, 2.0f, 12.0f)&#10;                curveTo(2.0f, 12.55f, 1.55f, 13.0f, 1.0f, 13.0f)&#10;                curveTo(0.45f, 13.0f, 0.0f, 12.55f, 0.0f, 12.0f)&#10;                curveTo(0.0f, 11.45f, 0.45f, 11.0f, 1.0f, 11.0f)&#10;                close()&#10;&#10;                moveTo(1.0f, 17.0f)&#10;                curveTo(1.55f, 17.0f, 2.0f, 17.45f, 2.0f, 18.0f)&#10;                curveTo(2.0f, 18.55f, 1.55f, 19.0f, 1.0f, 19.0f)&#10;                curveTo(0.45f, 19.0f, 0.0f, 18.55f, 0.0f, 18.0f)&#10;                curveTo(0.0f, 17.45f, 0.45f, 17.0f, 1.0f, 17.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customList!!&#10;    }&#10;&#10;private var _customList: ImageVector? = null&#10;&#10;// Custom Error Icon&#10;public val Icons.Filled.CustomErrorIcon: ImageVector&#10;    get() {&#10;        if (_customErrorIcon != null) {&#10;            return _customErrorIcon!!&#10;        }&#10;        _customErrorIcon = materialIcon(name = &quot;CustomErrorIcon&quot;) {&#10;            materialPath {&#10;                // Error circle background&#10;                moveTo(12.0f, 2.0f)&#10;                curveTo(6.48f, 2.0f, 2.0f, 6.48f, 2.0f, 12.0f)&#10;                curveTo(2.0f, 17.52f, 6.48f, 22.0f, 12.0f, 22.0f)&#10;                curveTo(17.52f, 22.0f, 22.0f, 17.52f, 22.0f, 12.0f)&#10;                curveTo(22.0f, 6.48f, 17.52f, 2.0f, 12.0f, 2.0f)&#10;                close()&#10;                &#10;                // Exclamation mark body&#10;                moveTo(11.0f, 7.0f)&#10;                horizontalLineTo(13.0f)&#10;                verticalLineTo(13.0f)&#10;                horizontalLineTo(11.0f)&#10;                close()&#10;                &#10;                // Exclamation mark dot&#10;                moveTo(11.0f, 15.0f)&#10;                horizontalLineTo(13.0f)&#10;                verticalLineTo(17.0f)&#10;                horizontalLineTo(11.0f)&#10;                close()&#10;            }&#10;        }&#10;        return _customErrorIcon!!&#10;    }&#10;&#10;private var _customErrorIcon: ImageVector? = null" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/settings/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/settings/SettingsScreen.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.settings&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.ui.icons.*&#10;&#10;@Composable&#10;fun SettingsScreen(&#10;    modifier: Modifier = Modifier&#10;) {&#10;&#10;    // State for expandable sections&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;        // Modern Header&#10;        Text(&#10;            text = &quot;Settings&quot;,&#10;            style = MaterialTheme.typography.headlineLarge,&#10;    var showThemeDialog by remember { mutableStateOf(false) }&#10;        if (uiState.isLoading) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;    var showThemeDialog by remember { mutableStateOf(false) }&#10;                isExpanded = themeExpanded,&#10;                onToggleExpanded = { themeExpanded = !themeExpanded }&#10;            ) {&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.CustomPalette,&#10;                    title = &quot;App Theme&quot;,&#10;                    subtitle = &quot;Choose your preferred visual style&quot;&#10;                )&#10;    var showThemeDialog by remember { mutableStateOf(false) }&#10;                modifier = Modifier.fillMaxSize(),&#10;    var showThemeDialog by remember { mutableStateOf(false) }&#10;            style = MaterialTheme.typography.headlineMedium,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;    var showThemeDialog by remember { mutableStateOf(false) }&#10;            style = MaterialTheme.typography.headlineMedium,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;    var showThemeDialog by remember { mutableStateOf(false) }&#10;            style = MaterialTheme.typography.headlineMedium,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;                        trailing = {&#10;                Column {&#10;        // Header&#10;                    SettingSectionHeader(title = &quot;Notifications&quot;)&#10;            // Settings List&#10;            style = MaterialTheme.typography.headlineMedium,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;                        trailing = {&#10;                Column {&#10;                .padding(16.dp)&#10;                    SettingSectionHeader(title = &quot;Notifications&quot;)&#10;            // Settings List&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;                        trailing = {&#10;                Column {&#10;                    // Notifications Section&#10;                    SettingSectionHeader(title = &quot;Notifications&quot;)&#10;            // Settings List&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;                        trailing = {&#10;                Column {&#10;                    // Notifications Section&#10;                    SettingSectionHeader(title = &quot;Notifications&quot;)&#10;&#10;                    SettingItem(&#10;                        icon = Icons.Default.Notifications,&#10;                        title = &quot;Daily Reminders&quot;,&#10;                        subtitle = &quot;Get reminded to perform daily acts of kindness&quot;,&#10;                        trailing = {&#10;                            Switch(&#10;                                checked = uiState.notificationEnabled,&#10;                                onCheckedChange = { viewModel.updateNotificationEnabled(it) }&#10;                            )&#10;                        }&#10;                    )&#10;                                onCheckedChange = { viewModel.updateLottieAnimations(it) }&#10;                    if (uiState.notificationEnabled) {&#10;                        SettingItem(&#10;                            icon = Icons.Default.DateRange,&#10;                            title = &quot;Notification Frequency&quot;,&#10;                            subtitle = uiState.notificationInterval.displayName,&#10;                            onClick = { showIntervalDialog = true }&#10;                        )&#10;                    SettingSectionHeader(title = &quot;About&quot;)&#10;                        SettingItem(&#10;                            icon = Icons.Default.Notifications,&#10;                            title = &quot;Notification Sound&quot;,&#10;                            subtitle = &quot;Play sound with notifications&quot;,&#10;                            trailing = {&#10;                                Switch(&#10;                                    checked = uiState.notificationSound,&#10;                                    onCheckedChange = { viewModel.updateNotificationSound(it) }&#10;                                )&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;                    // Appearance Section&#10;                    SettingSectionHeader(title = &quot;Appearance&quot;)&#10;&#10;                    SettingItem(&#10;                        icon = Icons.Default.Settings,&#10;                        title = &quot;App Theme&quot;,&#10;                        subtitle = uiState.selectedTheme.displayName,&#10;                        onClick = { showThemeDialog = true }&#10;                    )&#10;&#10;                    SettingItem(&#10;                        icon = Icons.Default.Star,&#10;                        title = &quot;Calming Backgrounds&quot;,&#10;                        subtitle = &quot;Use gentle gradient backgrounds&quot;,&#10;                        trailing = {&#10;                            Switch(&#10;                                checked = uiState.calmingBackground,&#10;                                onCheckedChange = { viewModel.updateCalmingBackground(it) }&#10;                    icon = Icons.Outlined.AchievementStar,&#10;                    title = &quot;Rate the App&quot;,&#10;                    subtitle = &quot;Help us improve by sharing your feedback&quot;&#10;                )&#10;            }&#10;&#10;            // Reset Button at Bottom&#10;            ResetSettingsButton(&#10;                onClick = { showResetDialog = true }&#10;            )&#10;&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                showThemeDialog = false&#10;                    // Experience Section&#10;                    SettingSectionHeader(title = &quot;Experience&quot;)&#10;&#10;                    SettingItem(&#10;                        icon = Icons.Default.Star,&#10;                        title = &quot;Celebration Animations&quot;,&#10;                        subtitle = &quot;Show animations when completing tasks&quot;,&#10;                        trailing = {&#10;                            Switch(&#10;                                checked = uiState.lottieAnimations,&#10;                                onCheckedChange = { viewModel.updateLottieAnimations(it) }&#10;                            )&#10;                        }&#10;                    )&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;        }&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;            }&#10;                    // About Section&#10;                    SettingSectionHeader(title = &quot;About&quot;)&#10;&#10;                    SettingItem(&#10;                        icon = Icons.Default.Info,&#10;                        title = &quot;Version&quot;,&#10;                        subtitle = &quot;2.0.0 - Enhanced with Phase 1 &amp; 2 Features&quot;&#10;        }&#10;    )&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&quot;Select App Theme&quot;)&#10;        },&#10;        text = {&#10;            Column {&#10;                themes.forEach { theme -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onThemeSelected(theme) }&#10;                            .padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = theme == currentTheme,&#10;                            onClick = { onThemeSelected(theme) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(theme.displayName)&#10;                    }&#10;}&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;                showThemeDialog = false&#10;    )&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&quot;Select App Theme&quot;)&#10;        },&#10;        text = {&#10;            Column {&#10;                themes.forEach { theme -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onThemeSelected(theme) }&#10;                            .padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = theme == currentTheme,&#10;                            onClick = { onThemeSelected(theme) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(theme.displayName)&#10;                    }&#10;}&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&quot;Select App Theme&quot;)&#10;        },&#10;        text = {&#10;            Column {&#10;                themes.forEach { theme -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onThemeSelected(theme) }&#10;                            .padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = theme == currentTheme,&#10;                            onClick = { onThemeSelected(theme) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(theme.displayName)&#10;                    }&#10;}&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&quot;Select App Theme&quot;)&#10;        },&#10;        text = {&#10;            Column {&#10;                themes.forEach { theme -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onThemeSelected(theme) }&#10;                            .padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = theme == currentTheme,&#10;                            onClick = { onThemeSelected(theme) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(theme.displayName)&#10;                    }&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = interval == currentInterval,&#10;                            onClick = { onIntervalSelected(interval) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(interval.displayName)&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;            Text(&quot;Select Notification Frequency&quot;)&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun ThemeSelectionDialog(&#10;    currentTheme: UserPreferencesManager.AppTheme,&#10;    onThemeSelected: (UserPreferencesManager.AppTheme) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    val themes = UserPreferencesManager.AppTheme.values()&#10;            Text(&quot;Select Notification Frequency&quot;)&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&quot;Select App Theme&quot;)&#10;        },&#10;        text = {&#10;            Column {&#10;                themes.forEach { theme -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onThemeSelected(theme) }&#10;                            .padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = theme == currentTheme,&#10;                            onClick = { onThemeSelected(theme) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(theme.displayName)&#10;                    }&#10;}&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&quot;Select App Theme&quot;)&#10;        },&#10;        text = {&#10;            Column {&#10;                themes.forEach { theme -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable { onThemeSelected(theme) }&#10;                            .padding(16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        RadioButton(&#10;                            selected = theme == currentTheme,&#10;                            onClick = { onThemeSelected(theme) }&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(theme.displayName)&#10;                    }&#10;}&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;) {&#10;    Text(&#10;        text = title,&#10;        style = MaterialTheme.typography.titleSmall,&#10;        color = MaterialTheme.colorScheme.primary,&#10;        fontWeight = FontWeight.Bold,&#10;        modifier = modifier.padding(16.dp)&#10;    )&#10;}&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    UserPreferencesManager.NotificationInterval.values().forEach { interval -&gt;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            RadioButton(&#10;                                selected = interval == uiState.notificationInterval,&#10;                                onClick = {&#10;                                    viewModel.updateNotificationInterval(interval)&#10;                                    showIntervalDialog = false&#10;            }&#10;        },&#10;        confirmButton = {},&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = { showIntervalDialog = false }&#10;                ) {&#10;                    Text(&quot;Done&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Reset Settings Dialog&#10;    if (showResetDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showResetDialog = false },&#10;            title = {&#10;                Text(&#10;                    text = &quot;Reset Settings&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;Are you sure you want to reset all settings to their default values? This action cannot be undone.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.resetToDefaults()&#10;                        showResetDialog = false&#10;                    },&#10;                    colors = ButtonDefaults.textButtonColors(&#10;                        contentColor = MaterialTheme.colorScheme.error&#10;                    )&#10;                ) {&#10;                    Text(&quot;Reset&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(&#10;                    onClick = { showResetDialog = false }&#10;                ) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.settings&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.ui.components.*&#10;import com.example.kindspark.ui.icons.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    viewModel: SettingsViewModel,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    var showIntervalDialog by remember { mutableStateOf(false) }&#10;    var showResetDialog by remember { mutableStateOf(false) }&#10;&#10;    // State for expandable sections&#10;    var themeExpanded by rememberSaveable { mutableStateOf(true) }&#10;    var notificationsExpanded by rememberSaveable { mutableStateOf(true) }&#10;    var aboutExpanded by rememberSaveable { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Modern Header&#10;        Text(&#10;            text = &quot;Settings&quot;,&#10;            style = MaterialTheme.typography.headlineLarge,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            textAlign = TextAlign.Center,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(24.dp)&#10;        )&#10;&#10;        if (uiState.isLoading) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                CircularProgressIndicator()&#10;            }&#10;        } else {&#10;            // Theme Section&#10;            ModernSettingSection(&#10;                title = &quot;Theme&quot;,&#10;                isExpanded = themeExpanded,&#10;                onToggleExpanded = { themeExpanded = !themeExpanded }&#10;            ) {&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.CustomPalette,&#10;                    title = &quot;App Theme&quot;,&#10;                    subtitle = &quot;Choose your preferred visual style&quot;&#10;                )&#10;&#10;                // Dynamic Theme Previews&#10;                LazyRow(&#10;                    modifier = Modifier.padding(horizontal = 20.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    items(UserPreferencesManager.AppTheme.values()) { theme -&gt;&#10;                        ThemePreviewCard(&#10;                            theme = theme,&#10;                            isSelected = theme == uiState.selectedTheme,&#10;                            onClick = { viewModel.updateSelectedTheme(theme) }&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                ModernSettingItem(&#10;                    icon = Icons.Default.Settings,&#10;                    title = &quot;Dark Mode&quot;,&#10;                    subtitle = &quot;Enable dark theme across the app&quot;,&#10;                    trailing = {&#10;                        ModernSwitch(&#10;                            checked = uiState.darkMode,&#10;                            onCheckedChange = { viewModel.updateDarkMode(it) }&#10;                        )&#10;                    }&#10;                )&#10;&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.CustomLandscape,&#10;                    title = &quot;Calming Backgrounds&quot;,&#10;                    subtitle = &quot;Use gentle gradient backgrounds&quot;,&#10;                    trailing = {&#10;                        ModernSwitch(&#10;                            checked = uiState.calmingBackground,&#10;                            onCheckedChange = { viewModel.updateCalmingBackground(it) }&#10;                        )&#10;                    }&#10;                )&#10;&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.CustomAutoAwesome,&#10;                    title = &quot;Celebration Animations&quot;,&#10;                    subtitle = &quot;Show animations when completing tasks&quot;,&#10;                    trailing = {&#10;                        ModernSwitch(&#10;                            checked = uiState.lottieAnimations,&#10;                            onCheckedChange = { viewModel.updateLottieAnimations(it) }&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Notifications Section&#10;            ModernSettingSection(&#10;                title = &quot;Notifications&quot;,&#10;                isExpanded = notificationsExpanded,&#10;                onToggleExpanded = { notificationsExpanded = !notificationsExpanded }&#10;            ) {&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.AnimatedBell,&#10;                    title = &quot;Daily Reminders&quot;,&#10;                    subtitle = &quot;Get reminded to perform daily acts of kindness&quot;,&#10;                    trailing = {&#10;                        ModernSwitch(&#10;                            checked = uiState.notificationEnabled,&#10;                            onCheckedChange = { viewModel.updateNotificationEnabled(it) }&#10;                        )&#10;                    }&#10;                )&#10;&#10;                if (uiState.notificationEnabled) {&#10;                    ModernSettingItem(&#10;                        icon = Icons.Outlined.CustomSchedule,&#10;                        title = &quot;Notification Frequency&quot;,&#10;                        subtitle = uiState.notificationInterval.displayName,&#10;                        onClick = { showIntervalDialog = true }&#10;                    )&#10;&#10;                    ModernSettingItem(&#10;                        icon = Icons.Outlined.CustomVolumeUp,&#10;                        title = &quot;Notification Sound&quot;,&#10;                        subtitle = &quot;Play sound with notifications&quot;,&#10;                        trailing = {&#10;                            ModernSwitch(&#10;                                checked = uiState.notificationSound,&#10;                                onCheckedChange = { viewModel.updateNotificationSound(it) }&#10;                            )&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // About Section&#10;            ModernSettingSection(&#10;                title = &quot;About&quot;,&#10;                isExpanded = aboutExpanded,&#10;                onToggleExpanded = { aboutExpanded = !aboutExpanded }&#10;            ) {&#10;                ModernSettingItem(&#10;                    icon = Icons.Default.Info,&#10;                    title = &quot;Version&quot;,&#10;                    subtitle = &quot;2.0.0 - Enhanced with Modern UX&quot;&#10;                )&#10;&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.SparklingHeart,&#10;                    title = &quot;Made with &quot;,&#10;                    subtitle = &quot;Crafted to spread kindness and positivity&quot;&#10;                )&#10;&#10;                ModernSettingItem(&#10;                    icon = Icons.Outlined.AchievementStar,&#10;                    title = &quot;Rate the App&quot;,&#10;                    subtitle = &quot;Help us improve by sharing your feedback&quot;&#10;                )&#10;            }&#10;&#10;            // Reset Button at Bottom&#10;            ResetSettingsButton(&#10;                onClick = { showResetDialog = true }&#10;            )&#10;&#10;            // Add bottom padding for better scrolling experience&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;        }&#10;    }&#10;&#10;    // Notification Interval Dialog&#10;    if (showIntervalDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showIntervalDialog = false },&#10;            title = {&#10;                Text(&#10;                    text = &quot;Notification Frequency&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;            },&#10;            text = {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;How often would you like to receive reminders?&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    UserPreferencesManager.NotificationInterval.values().forEach { interval -&gt;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            RadioButton(&#10;                                selected = interval == uiState.notificationInterval,&#10;                                onClick = {&#10;                                    viewModel.updateNotificationInterval(interval)&#10;                                    showIntervalDialog = false&#10;                                }&#10;                            )&#10;                            Spacer(modifier = Modifier.width(12.dp))&#10;                            Text(&#10;                                text = interval.displayName,&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = { showIntervalDialog = false }&#10;                ) {&#10;                    Text(&quot;Done&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    // Reset Settings Dialog&#10;    if (showResetDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showResetDialog = false },&#10;            title = {&#10;                Text(&#10;                    text = &quot;Reset Settings&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;            },&#10;            text = {&#10;                Text(&#10;                    text = &quot;Are you sure you want to reset all settings to their default values? This action cannot be undone.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.resetToDefaults()&#10;                        showResetDialog = false&#10;                    },&#10;                    colors = ButtonDefaults.textButtonColors(&#10;                        contentColor = MaterialTheme.colorScheme.error&#10;                    )&#10;                ) {&#10;                    Text(&quot;Reset&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(&#10;                    onClick = { showResetDialog = false }&#10;                ) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/settings/SettingsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/settings/SettingsViewModel.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.settings&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;&#10;data class SettingsUiState(&#10;    val notificationEnabled: Boolean = true,&#10;    val notificationInterval: UserPreferencesManager.NotificationInterval = UserPreferencesManager.NotificationInterval.ONCE_DAILY,&#10;    val notificationSound: Boolean = true,&#10;    val selectedTheme: UserPreferencesManager.AppTheme = UserPreferencesManager.AppTheme.LIGHT,&#10;    val isLoading: Boolean = false&#10;)&#10;&#10;class SettingsViewModel(&#10;    private val preferencesManager: UserPreferencesManager,&#10;    private val notificationScheduler: NotificationScheduler&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(SettingsUiState())&#10;    val uiState: StateFlow&lt;SettingsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadSettings()&#10;    }&#10;&#10;    private fun loadSettings() {&#10;        viewModelScope.launch {&#10;            combine(&#10;                preferencesManager.notificationEnabled,&#10;                preferencesManager.notificationInterval,&#10;                preferencesManager.notificationSound,&#10;                preferencesManager.selectedTheme,&#10;                preferencesManager.calmingBackground,&#10;            ) { values -&gt;&#10;                val notificationEnabled = values[0] as Boolean&#10;                val notificationInterval = values[1] as UserPreferencesManager.NotificationInterval&#10;                val selectedTheme = values[3] as UserPreferencesManager.AppTheme&#10;                val calmingBackground = values[4] as Boolean&#10;                val lottieAnimations = values[5] as Boolean&#10;&#10;                SettingsUiState(&#10;                    notificationEnabled = notificationEnabled,&#10;                val calmingBackground = values[4] as Boolean&#10;                val lottieAnimations = values[5] as Boolean&#10;                    calmingBackground = calmingBackground,&#10;                    lottieAnimations = lottieAnimations,&#10;                val calmingBackground = values[4] as Boolean&#10;                val lottieAnimations = values[5] as Boolean&#10;                _uiState.value = newState&#10;            }&#10;        }&#10;&#10;    fun updateNotificationEnabled(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateNotificationEnabled(enabled)&#10;            // Reschedule or cancel notifications based on the new setting&#10;            if (enabled) {&#10;            } else {&#10;                notificationScheduler.cancelNotifications()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateNotificationInterval(interval: UserPreferencesManager.NotificationInterval) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateNotificationInterval(interval)&#10;            // Reschedule notifications with the new interval&#10;            if (_uiState.value.notificationEnabled) {&#10;                notificationScheduler.rescheduleNotifications()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateNotificationSound(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateNotificationSound(enabled)&#10;        }&#10;    }&#10;&#10;    fun updateSelectedTheme(theme: UserPreferencesManager.AppTheme) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateSelectedTheme(theme)&#10;        }&#10;    }&#10;&#10;    fun updateCalmingBackground(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateCalmingBackground(enabled)&#10;        }&#10;    }&#10;&#10;    fun updateLottieAnimations(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateLottieAnimations(enabled)&#10;        }&#10;    }&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.settings&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.kindspark.data.preferences.UserPreferencesManager&#10;import com.example.kindspark.notifications.NotificationScheduler&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;&#10;data class SettingsUiState(&#10;    val notificationEnabled: Boolean = true,&#10;    val notificationInterval: UserPreferencesManager.NotificationInterval = UserPreferencesManager.NotificationInterval.ONCE_DAILY,&#10;    val notificationSound: Boolean = true,&#10;    val selectedTheme: UserPreferencesManager.AppTheme = UserPreferencesManager.AppTheme.LIGHT,&#10;    val darkMode: Boolean = false,&#10;    val calmingBackground: Boolean = true,&#10;    val lottieAnimations: Boolean = true,&#10;    val isLoading: Boolean = false&#10;)&#10;&#10;class SettingsViewModel(&#10;    private val preferencesManager: UserPreferencesManager,&#10;    private val notificationScheduler: NotificationScheduler&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(SettingsUiState())&#10;    val uiState: StateFlow&lt;SettingsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadSettings()&#10;    }&#10;&#10;    private fun loadSettings() {&#10;        viewModelScope.launch {&#10;            combine(&#10;                preferencesManager.notificationEnabled,&#10;                preferencesManager.notificationInterval,&#10;                preferencesManager.notificationSound,&#10;                preferencesManager.selectedTheme,&#10;                preferencesManager.darkMode,&#10;                preferencesManager.calmingBackground,&#10;                preferencesManager.lottieAnimations&#10;            ) { values -&gt;&#10;                val notificationEnabled = values[0] as Boolean&#10;                val notificationInterval = values[1] as UserPreferencesManager.NotificationInterval&#10;                val notificationSound = values[2] as Boolean&#10;                val selectedTheme = values[3] as UserPreferencesManager.AppTheme&#10;                val darkMode = values[4] as Boolean&#10;                val calmingBackground = values[5] as Boolean&#10;                val lottieAnimations = values[6] as Boolean&#10;&#10;                SettingsUiState(&#10;                    notificationEnabled = notificationEnabled,&#10;                    notificationInterval = notificationInterval,&#10;                    notificationSound = notificationSound,&#10;                    selectedTheme = selectedTheme,&#10;                    darkMode = darkMode,&#10;                    calmingBackground = calmingBackground,&#10;                    lottieAnimations = lottieAnimations,&#10;                    isLoading = false&#10;                )&#10;            }.collect { newState -&gt;&#10;                _uiState.value = newState&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateNotificationEnabled(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateNotificationEnabled(enabled)&#10;            // Reschedule or cancel notifications based on the new setting&#10;            if (enabled) {&#10;                notificationScheduler.scheduleNotifications()&#10;            } else {&#10;                notificationScheduler.cancelNotifications()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateNotificationInterval(interval: UserPreferencesManager.NotificationInterval) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateNotificationInterval(interval)&#10;            // Reschedule notifications with the new interval&#10;            if (_uiState.value.notificationEnabled) {&#10;                notificationScheduler.rescheduleNotifications()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateNotificationSound(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateNotificationSound(enabled)&#10;        }&#10;    }&#10;&#10;    fun updateSelectedTheme(theme: UserPreferencesManager.AppTheme) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateSelectedTheme(theme)&#10;        }&#10;    }&#10;&#10;    fun updateDarkMode(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateDarkMode(enabled)&#10;        }&#10;    }&#10;&#10;    fun updateCalmingBackground(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateCalmingBackground(enabled)&#10;        }&#10;    }&#10;&#10;    fun updateLottieAnimations(enabled: Boolean) {&#10;        viewModelScope.launch {&#10;            preferencesManager.updateLottieAnimations(enabled)&#10;        }&#10;    }&#10;&#10;    fun resetToDefaults() {&#10;        viewModelScope.launch {&#10;            preferencesManager.resetToDefaults()&#10;            // Reschedule notifications with default settings&#10;            notificationScheduler.scheduleNotifications()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/theme/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/theme/Color.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;// Kind Spark Colors&#10;val KindnessGreen = Color(0xFF4CAF50)&#10;val KindnessGreenLight = Color(0xFF81C784)&#10;val KindnessGreenDark = Color(0xFF2E7D32)&#10;&#10;val WarmOrange = Color(0xFFFF9800)&#10;val WarmOrangeLight = Color(0xFFFFB74D)&#10;val WarmOrangeDark = Color(0xFFF57C00)&#10;&#10;val SoftBlue = Color(0xFF2196F3)&#10;val SoftBlueLight = Color(0xFF64B5F6)&#10;val SoftBlueDark = Color(0xFF1976D2)&#10;&#10;val NeutralGray = Color(0xFF757575)&#10;val LightGray = Color(0xFFF5F5F5)&#10;val DarkGray = Color(0xFF424242)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;// Kind Spark Colors&#10;val KindnessGreen = Color(0xFF4CAF50)&#10;val KindnessGreenLight = Color(0xFF81C784)&#10;val KindnessGreenDark = Color(0xFF2E7D32)&#10;&#10;val WarmOrange = Color(0xFFFF9800)&#10;val WarmOrangeLight = Color(0xFFFFB74D)&#10;val WarmOrangeDark = Color(0xFFF57C00)&#10;&#10;val SoftBlue = Color(0xFF2196F3)&#10;val SoftBlueLight = Color(0xFF64B5F6)&#10;val SoftBlueDark = Color(0xFF1976D2)&#10;&#10;val NeutralGray = Color(0xFF757575)&#10;val LightGray = Color(0xFFF5F5F5)&#10;val DarkGray = Color(0xFF424242)&#10;&#10;// Calm Ocean Theme Colors&#10;val CalmOceanPrimary = Color(0xFF87CEEB)        // Soft Blue&#10;val CalmOceanPrimaryDark = Color(0xFF4682B4)    // Steel Blue&#10;val CalmOceanAccent = Color(0xFFFFFFFF)         // White&#10;val CalmOceanSurface = Color(0xFFF0F8FF)        // Alice Blue&#10;val CalmOceanContainer = Color(0xFFE6F3FF)      // Light Blue Container&#10;&#10;// Warm Sunset Theme Colors&#10;val WarmSunsetPrimary = Color(0xFFFFAB91)       // Peach/Light Orange&#10;val WarmSunsetPrimaryDark = Color(0xFFFF5722)   // Deep Orange&#10;val WarmSunsetAccent = Color(0xFFFFEB3B)        // Yellow&#10;val WarmSunsetSurface = Color(0xFFFFF8E1)       // Light Amber&#10;val WarmSunsetContainer = Color(0xFFFFE0B2)     // Orange Container&#10;&#10;// Serene Forest Theme Colors&#10;val SereneForestPrimary = Color(0xFF8FBC8F)     // Sage Green&#10;val SereneForestPrimaryDark = Color(0xFF228B22) // Forest Green&#10;val SereneForestAccent = Color(0xFFF5F5DC)      // Cream&#10;val SereneForestSurface = Color(0xFFF0FFF0)     // Honeydew&#10;val SereneForestContainer = Color(0xFFE8F5E8)   // Light Green Container&#10;&#10;// Midnight Calm Theme Colors&#10;val MidnightCalmPrimary = Color(0xFF191970)     // Midnight Blue/Deep Navy&#10;val MidnightCalmPrimaryDark = Color(0xFF0F0F23) // Very Dark Navy&#10;val MidnightCalmAccent = Color(0xFF008B8B)      // Teal&#10;val MidnightCalmSurface = Color(0xFF1E1E2E)     // Dark Surface&#10;val MidnightCalmContainer = Color(0xFF2A2A3E)   // Dark Container" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/kindspark/ui/theme/Theme.kt" />
              <option name="originalContent" value="package com.example.kindspark.ui.theme&#10;&#10;import android.app.Activity&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.SideEffect&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.core.view.WindowCompat&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = KindnessGreenLight,&#10;    secondary = WarmOrangeLight,&#10;    tertiary = SoftBlueLight,&#10;    background = DarkGray,&#10;    surface = Color(0xFF1C1B1F),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color.White,&#10;    onSurface = Color.White,&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = KindnessGreen,&#10;    secondary = WarmOrange,&#10;    tertiary = SoftBlue,&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;    primaryContainer = Color(0xFFE8F5E8),&#10;    onPrimaryContainer = KindnessGreenDark,&#10;    secondaryContainer = Color(0xFFFFF3E0),&#10;    onSecondaryContainer = WarmOrangeDark,&#10;    errorContainer = Color(0xFFFFDAD6),&#10;    onErrorContainer = Color(0xFF410002),&#10;)&#10;&#10;@Composable&#10;fun KindSparkTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;    val view = LocalView.current&#10;    if (!view.isInEditMode) {&#10;        SideEffect {&#10;            val window = (view.context as Activity).window&#10;            window.statusBarColor = colorScheme.primary.toArgb()&#10;            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme&#10;        }&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.kindspark.ui.theme&#10;&#10;import android.app.Activity&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.SideEffect&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.core.view.WindowCompat&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = KindnessGreenLight,&#10;    secondary = WarmOrangeLight,&#10;    tertiary = SoftBlueLight,&#10;    background = DarkGray,&#10;    surface = Color(0xFF1C1B1F),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color.White,&#10;    onSurface = Color.White,&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = KindnessGreen,&#10;    secondary = WarmOrange,&#10;    tertiary = SoftBlue,&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.White,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;    primaryContainer = Color(0xFFE8F5E8),&#10;    onPrimaryContainer = KindnessGreenDark,&#10;    secondaryContainer = Color(0xFFFFF3E0),&#10;    onSecondaryContainer = WarmOrangeDark,&#10;    errorContainer = Color(0xFFFFDAD6),&#10;    onErrorContainer = Color(0xFF410002),&#10;)&#10;&#10;@Composable&#10;fun KindSparkTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;    val view = LocalView.current&#10;    if (!view.isInEditMode) {&#10;        SideEffect {&#10;            val window = (view.context as Activity).window&#10;            window.statusBarColor = colorScheme.primary.toArgb()&#10;            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme&#10;        }&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = KindSparkTypography, // Use our custom typography here&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/splash_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/splash_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;!-- Background color --&gt;&#10;    &lt;item android:drawable=&quot;@color/white&quot; /&gt;&#10;    &#10;    &lt;!-- App logo centered --&gt;&#10;    &lt;item&gt;&#10;        &lt;bitmap&#10;            android:gravity=&quot;center&quot;&#10;            android:src=&quot;@drawable/kindspark_logo&quot; /&gt;&#10;    &lt;/item&gt;&#10;&lt;/layer-list&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/font_certs.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/font_certs.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;resources&gt;&#10;    &lt;array name=&quot;com_google_android_gms_fonts_certs&quot;&gt;&#10;        &lt;item&gt;@array/com_google_android_gms_fonts_certs_dev&lt;/item&gt;&#10;        &lt;item&gt;@array/com_google_android_gms_fonts_certs_prod&lt;/item&gt;&#10;    &lt;/array&gt;&#10;    &lt;string-array name=&quot;com_google_android_gms_fonts_certs_dev&quot;&gt;&#10;        &lt;item&gt;&#10;            MIIEqDCCA5CgAwIBAgIJANWFuGx90071MA0GCSqGSIb3DQEBBAUAMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTAeFw0wODA0MTUyMzM2NTZaFw0zNTA5MDEyMzM2NTZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBANbOLggKv+IxTdGNs8/TGFy0PTP6DHThvbbR24kT9ixcOd9W+EaBPWW+wPPKQmsHxajtWjmQwWfna8mZuSeJS48LIgAZlKkpFeVyxW0qMBujb8X8ETrWy550NaFtI6t9+u7hZeTfHwqNvacKhp1RbE6dBRGWynwMVX8XW8N1+UjFaq6GCJukT4qmpN2afb8sCjUigq0GuMwYXrFVee74bQgMc5ob9hdC7lfJt3IIFQ9umhVZ5eaVHFD6G+VAE6iN7JjGDmCkbKbwTCYAFb98S5ONJ2cPiNNm5MW2RRgdcA+UZlp/LRwD8UioY6is8hdUP337atyQ5y0P8P7s1kscv+1yTnD0E9ikJyoopNaXcH/xjyMRmrtKelB4cPvj2d4fswvdnNna3Ui8ArVk5F7U1sIYU5II4zEiJjAdx8p3cLR/Xxn+bbnH2hx8jAz8tM+7Ph8QfeUzW18MR0U7NPPikYZQn29xsh+BOA2vcUVgIHSUEH/YFHOqaK7GHXYEOwARAQAB&#10;        &lt;/item&gt;&#10;    &lt;/string-array&gt;&#10;    &lt;string-array name=&quot;com_google_android_gms_fonts_certs_prod&quot;&gt;&#10;        &lt;item&gt;&#10;            MIIEQzCCAyugAwIBAgIJAMLgh0ZkSjCNMA0GCSqGSIb3DQEBBAUAMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDAeFw0wODA4MjEyMzEzMzRaFw0zNjAxMDcyMzEzMzRaMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBAKtWLgDYO6IIrgqWbxJOKdoR8qtW0I9Y4sypEwPpt1TTcvZApxsdyxMJZ2JORland2qSGT2y5b+3JKkedxiLDmpHpDsz2WCbdxgxRczfey5YZnTJ4VZbH0xqWVW/8lGmPav5xVwnIiJS6HXk+BVKZF+JcWjAsb/GEuq/eFdpuzSqeYTcfi6idkyugwfYwXFU1+5fZKUaRKYCwkkFQVfcAs1fXA5V+++FGfvjJ/CxURaSxaBvGdGDhfXE28LWuT9ozCl5xw4Yq5OGazvV24mZVSoOO0yZ31j7kYvtwYK6NeADwbSxDdJEqO4k//0zOHKrUiGYXtqw/A0LFFtqoZKFjnkCAQOjgdkwgdYwHQYDVR0OBBYEFMd9jMIhF1Ylmn/Tgt9r45jk14alMIGmBgNVHSMEgZ4wgZuAFMd9jMIhF1Ylmn/Tgt9r45jk14aloXikdjB0MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLR29vZ2xlIEluYy4xEDAOBgNVBAsTB0FuZHJvaWQxEDAOBgNVBAMTB0FuZHJvaWSCCQDC4IdGZEowjTAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBAUAA4IBAQBt0lLO74UwLDYKqs6Tm8/yzKkEu116FmH4rkaymUIE0P9KaMftGlMexFlaYjzmB2OxZyl6euNXEsQH8gjwyxCUKRJNexBiGcCEyj6z+a1fuHHvkiaai+KL8W1EyNmgjmyy8AW7P+LLlkR+ho5zEHatRbM/YAnqGcFh5iZBqpknHf1SKMXFh4dd239FJ1jWYfbMDMy3NS5CTMQ2XFI1MvcyUTdZPErjQfTbQe3aDQsQcafEQPD+nqActifKZ0Np0IS9L9kR/wbNvyz6ENwPiTrjV2KRkEjH78ZMcUQXg0L3BYHJ3lc69Vs5Ddf9uUGGMYldX3WfMBEmh/9iFBDAaTCK&#10;        &lt;/item&gt;&#10;    &lt;/string-array&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/styles.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/styles.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;style name=&quot;Theme.Splash&quot; parent=&quot;Theme.KindSpark&quot;&gt;&#10;        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_logo&lt;/item&gt;&#10;    &lt;/style&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;!-- Theme.Splash has been moved to themes.xml for better organization --&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/themes.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/themes.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;resources&gt;&#10;&#10;    &lt;style name=&quot;Theme.KindSpark&quot; parent=&quot;android:Theme.Material.Light.NoActionBar&quot; /&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;resources&gt;&#13;&#10;&#13;&#10;    &lt;style name=&quot;Theme.KindSpark&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot; /&gt;&#13;&#10;    &#13;&#10;    &lt;style name=&quot;Theme.Splash&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;&#13;&#10;        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_background&lt;/item&gt;&#13;&#10;        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;&#13;&#10;        &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;&#13;&#10;        &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;&#13;&#10;    &lt;/style&gt;&#13;&#10;    &#13;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>